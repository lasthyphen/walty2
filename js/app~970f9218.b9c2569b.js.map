{"version":3,"sources":["webpack:///./src/js/wallets/MnemonicWallet.ts","webpack:///./src/js/ERC721Token.ts","webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/Erc20Token.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/js/wallets/MnemonicPhrase.ts","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/js/wallets/WalletCore.ts","webpack:///./src/js/AvaAsset.ts"],"names":["AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","LEDGER_ETH_ACCOUNT_PATH","MnemonicWallet","mnemonic","seed","masterHdKey","fromMasterSeed","accountHdKey","derive","ethAccountKey","ethPrivateKey","privateKey","ethKey","toString","ethAddress","ethBalance","cPrivKey","cb58Encode","from","ethKeyBech","cKeyChain","getHRP","ethKeyChain","importKey","type","hdKey","isLoading","this","getEthBalance","bal","to","amount","gasPrice","gasLimit","sendEth","token","estimateGas","sendErc20","isFetchUtxos","isInit","externalHelper","internalHelper","platformHelper","setTimeout","getUTXOs","getStake","getCurrentKey","getValue","nodeID","amt","start","end","delegationFee","rewardAddress","utxos","validate","delegate","stakeAmount","orders","addr","memo","issueBatchTx","internal","getAllDerivedKeys","external","allKeys","concat","keychain","getNetworkID","chainId","i","length","addKey","unsignedTx","getKeyChain","tx","sign","getKeychain","keyChain","keyBuff","Buffer","index","hash","key","getKeyForIndex","signed","name","symbol","groupNum","createNftFamily","mintUtxo","payload","quantity","mintNft","ERC721MetadataID","ERC721EnumerableID","ERC721Token","data","tokenCache","uriDataCache","canSupport","contractAddress","address","contract","eth","Contract","abi","updateSupports","methods","supportsInterface","call","metadata","enumerable","balanceOf","getBalance","res","tokenOfOwnerByIndex","tokenId","push","getAllTokensIds","ids","id","getTokenURI","parseInt","transferFrom","tokenURI","uri","a","get","network_id","AvaNetwork","url","networkId","explorerUrl","explorerSiteUrl","readonly","withCredentials","protocol","port","ip","updateURL","post","jsonrpc","method","err","split","includes","urlSplit","Erc20Token","tokenData","balanceRaw","balanceBN","balanceBig","tokenInst","transfer","decimals","console","log","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","ParseableEvmTxEnum","buildUnsignedTransaction","derivedAddresses","utxoset","changeAddress","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getDJTXAssetID","DJTX_ID_BUF","DJTX_ID_STR","TO_BUF","aad","ZERO","isFeeAdded","order","asset","assetId","cb58Decode","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","b","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","baseTx","buildCreateNftFamilyTx","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","buildCreateNFTAssetTx","buildMintNftTx","ownerAddress","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildEvmTransferNativeTx","getTransactionCount","nonce","getChainId","net","getId","chainParams","common","forCustomChain","value","buildEvmTransferErc20Tx","tokenTx","createTransferTx","encodeABI","buildEvmTransferErc721Tx","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","password","slt","pw","sha256","pwkey","window","crypto","subtle","Uint8Array","keyMaterial","salt","deriveKey","iterations","message","buff","update","digest","alloc","getRandomValues","makeSalt","_pwcleaner","plaintext","pt","_keyMaterial","_deriveKey","pkey","iv","encrypt","additionalData","ciphertext","decrypt","cryptoHelpers","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key_decrypt","key_string","activeIndex","readV3","pwhash","readV4","readV5","readV6","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","wallet","getMnemonic","pk_crypt","file_data","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","hrp","keyCache","addressCache","hdCache","hdIndex","findHdIndex","clearCache","oninit","newIndex","newKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","error","addrs","getAllDerivedAddresses","result","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","incrementIndex","upTo","set","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","idx","getFirstAvailableIndex","cacheExternal","pkHex","derivationPath","publicKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","indexOf","ethHdNode","accountNodeXP","then","updateInitState","toJSON","xpub","pubKeyHash","setExternal","setInternal","joined","merge","getFirstAvailableAddress","updateUTXOsX","updateUTXOsP","updateUTXOsExternal","updateUTXOsInternal","updateUtxos","updateFetchState","updateAvmUTXOSet","getDerivedAddresses","getDerivedAddressesP","internalIndex","externalIndex","Math","max","onNetworkChange","getChangeAddressAvm","getUTXOSet","indexX","findAddressIndex","indexP","Error","msgStr","findExternalAddressIndex","signMessageByExternalIndex","digestHex","digestBuff","signHashByExternalIndex","msg","signMessageByExternalAddress","WalletCore","bippath","MIN_EVM_SUPPORT_V","LedgerWallet","app","hdkey","config","hdEth","ethApp","ethPublic","toBuffer","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isDjtxOnly","item","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","getSource","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","uniquePaths","bip32Paths","path","fromString","chainChangePath","getChangePath","changeIdx","getChangeIndex","sigMap","CredentialClass","creds","evmInputs","cred","getCredentialID","pathIndex","sigRaw","sigBuff","sig","fromBuffer","addSignature","evmInput","txbuff","commit","title","messages","info","toUpperCase","pathsToUniqueBipPaths","accountPathSource","accountPath","signHash","getCredentials","signedTx","parseableTxs","V","M","U","getChangeBipPath","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getExportOutputs","getExportedOutputs","destinationChain","getAddress","getAmount","toPathArray","getChangeFromIndex","getAddresses","forEach","format","getNodeID","startTime","getStartTime","toNumber","utc","endTime","getEndTime","stakeAmt","getStakeAmount","rewardOwners","getRewardOwners","rewardAddrs","join","outputMessages","getOutputMsgs","validateDelegateMessages","getValidateDelegateMsgs","feeMessages","getFeeMsgs","totFee","mul","feeNano","msgs","test","decodeMethod","callMsg","paramMsgs","params","param","feeMsg","toLocaleString","getTransactionPaths","canLedgerParse","isParsableType","signTransactionParsable","signTransactionHash","txIns","typeID","getTypeID","STAKEABLELOCKINID","destChainBuff","getDestinationChain","destChain","sourceChainBuff","getSourceChain","sourceChain","typeId","input","txSigned","rawUnsignedTx","encode","buf","getEvmTransactionMessages","signature","signatureBN","v","r","s","fromTxData","externalAddrs","getExtendedAddresses","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","addressPath","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","ethRes","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","randomstring","MnemonicPhrase","generate","encrypted","decrypted","enc","Utf8","SingletonWallet","chainIdP","keyPair","platformKeyChain","platformKeyPair","pkBuffNative","cKeypair","ethAddressBech","getAddressString","getCurrentAddressAvm","getCurrentAddressPlatform","platformUtxoset","AvaNftFamily","uniqid","getEvmAddressBech","evmGetAtomicUTXOs","fee","bechAddr","hexAddr","getEvmAddress","toAddress","ownerAddresses","sourceChainId","buildImportTx","getAllUTXOs","createImportTxC","unsignedTxFee","signC","issueC","importFee","amtFee","clone","destinationAddr","add","getAllAddressesX","buildAvmExportTransaction","exportTx","signX","issueX","getPlatformUTXOSet","pChangeAddr","getAllAddressesP","buildPlatformExportTransaction","signP","issueP","exportFee","buildEvmExportTransaction","estimateExportGasFee","avmGetAtomicUTXOs","platformGetAtomicUTXOs","pToAddr","utxoAddrs","ownerAddrs","xToAddr","AvaAsset","denomination","amountLocked","amountExtra","amountMultisig","pow","locked","div","big","getTotalAmount"],"mappings":"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","file":"js/app~970f9218.b9c2569b.js","sourcesContent":["// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n  KeyPair as AVMKeyPair,\n  KeyChain as AVMKeyChain,\n  UTXOSet as AVMUTXOSet,\n  TransferableInput,\n  TransferableOutput,\n  BaseTx,\n  UnsignedTx as AVMUnsignedTx,\n  Tx as AVMTx,\n  UTXO as AVMUTXO,\n  AssetAmountDestination,\n  UTXOSet,\n} from \"avalanche/dist/apis/avm\";\n\nimport { privateToAddress } from \"ethereumjs-util\";\n\nimport {\n  KeyChain as PlatformVMKeyChain,\n  UnsignedTx as PlatformUnsignedTx,\n  UTXO as PlatformUTXO,\n  Tx as PlatformTx,\n} from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  KeyChain as EVMKeyChain,\n  UnsignedTx as EVMUnsignedTx,\n  Tx as EvmTx,\n} from \"avalanche/dist/apis/evm\";\nimport { getPreferredHRP, PayloadBase } from \"avalanche/dist/utils\";\n\nimport * as bip39 from \"bip39\";\nimport { BN, Buffer as BufferAvalanche } from \"avalanche\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport {\n  AvmExportChainType,\n  AvmImportChainType,\n  IAvaHdWallet,\n} from \"@/js/wallets/types\";\nimport HDKey from \"hdkey\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { KeyPair as PlatformVMKeyPair } from \"avalanche/dist/apis/platformvm\";\nimport { HdWalletCore } from \"@/js/wallets/HdWalletCore\";\nimport { WalletNameType } from \"@/js/wallets/types\";\nimport { digestMessage } from \"@/helpers/helper\";\nimport { KeyChain } from \"avalanche/dist/apis/evm\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport MnemonicPhrase from \"@/js/wallets/MnemonicPhrase\";\nimport { ExportChainsC, ExportChainsP } from \"@avalabs/avalanche-wallet-sdk\";\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = \"9000\";\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'`; // Change and index left out\nexport const ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`;\nexport const LEDGER_ETH_ACCOUNT_PATH = ETH_ACCOUNT_PATH + \"/0/0\";\n\nconst INDEX_RANGE: number = 20; // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70; // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE; // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class MnemonicWallet\n  extends HdWalletCore\n  implements IAvaHdWallet {\n  seed: string;\n  hdKey: HDKey;\n  private mnemonic: MnemonicPhrase;\n  isLoading: boolean;\n  type: WalletNameType;\n  ethKey: string;\n  ethKeyBech: string;\n  ethKeyChain: EVMKeyChain;\n  ethAddress: string;\n  ethBalance: BN;\n\n  // TODO : Move to hd core class\n  onnetworkchange() {\n    super.onnetworkchange();\n\n    // Update EVM values\n    this.ethKeyChain = new EVMKeyChain(ava.getHRP(), \"U\");\n    const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech);\n    this.ethBalance = new BN(0);\n  }\n\n  // The master key from avalanche.js\n  constructor(mnemonic: string) {\n    const seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic);\n    const masterHdKey: HDKey = HDKey.fromMasterSeed(seed);\n    const accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH);\n    const ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + \"/0/0\");\n\n    super(accountHdKey, ethAccountKey, false);\n\n    // Derive EVM key and address\n    const ethPrivateKey = ethAccountKey.privateKey;\n    this.ethKey = ethPrivateKey.toString(\"hex\");\n    this.ethAddress = privateToAddress(ethPrivateKey).toString(\"hex\");\n    this.ethBalance = new BN(0);\n\n    const cPrivKey =\n      `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(ethPrivateKey));\n    this.ethKeyBech = cPrivKey;\n\n    const cKeyChain = new KeyChain(ava.getHRP(), \"U\");\n    this.ethKeyChain = cKeyChain;\n\n    const cKeypair = cKeyChain.importKey(cPrivKey);\n\n    this.type = \"mnemonic\";\n    this.seed = seed.toString(\"hex\");\n    this.hdKey = masterHdKey;\n    this.mnemonic = new MnemonicPhrase(mnemonic);\n    this.isLoading = false;\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n\n  async getUTXOs(): Promise<void> {\n    // TODO: Move to shared file\n    this.isFetchUtxos = true;\n    // If we are waiting for helpers to initialize delay the call\n    const isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n    if (!isInit) {\n      setTimeout(() => {\n        this.getUTXOs();\n      }, 1000);\n      return;\n    }\n\n    super.getUTXOs();\n    this.getStake();\n    this.getEthBalance();\n    return;\n  }\n\n  getCurrentKey(): AVMKeyPair {\n    return this.externalHelper.getCurrentKey() as AVMKeyPair;\n  }\n\n  /**\n   * Returns the mnemonic phrase of this wallet\n   */\n  getMnemonic(): string {\n    return this.mnemonic.getValue();\n  }\n\n  getMnemonicEncrypted(): MnemonicPhrase {\n    return this.mnemonic;\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number = 0,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  // Delegates DJTX to the given node ID\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: BufferAvalanche | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  // returns a keychain that has all the derived private/public keys for X chain\n  getKeyChain(): AVMKeyChain {\n    const internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[];\n    const external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[];\n\n    const allKeys = internal.concat(external);\n    const keychain: AVMKeyChain = new AVMKeyChain(\n      getPreferredHRP(ava.getNetworkID()),\n      this.chainId\n    );\n\n    for (let i = 0; i < allKeys.length; i++) {\n      keychain.addKey(allKeys[i]);\n    }\n    return keychain;\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const keychain = this.getKeyChain();\n\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain;\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    const keyChain = this.ethKeyChain;\n    return unsignedTx.sign(keyChain);\n  }\n\n  async signEvm(tx: Transaction) {\n    const keyBuff = Buffer.from(this.ethKey, \"hex\");\n    return tx.sign(keyBuff);\n  }\n\n  async signHashByExternalIndex(index: number, hash: BufferAvalanche) {\n    const key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair;\n    const signed = key.sign(hash);\n    return bintools.cb58Encode(signed);\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n}\n","import { web3 } from \"@/evm\";\nimport ERC721Abi from \"@openzeppelin/contracts/build/contracts/ERC721Enumerable.json\";\nimport { ERC721TokenInput } from \"@/store/modules/assets/modules/types\";\nimport axios from \"axios\";\n\ninterface TokenDataCache {\n  [index: number]: string;\n}\n\ninterface URIDataCache {\n  [index: number]: string;\n}\n\nconst ERC721MetadataID = \"0x5b5e139f\";\nconst ERC721EnumerableID = \"0x780e9d63\";\n\nclass ERC721Token {\n  contractAddress: string;\n  contract: any;\n  name = \"\";\n  symbol = \"\";\n  data: ERC721TokenInput;\n  tokenCache: TokenDataCache = {};\n  uriDataCache: URIDataCache = {};\n  canSupport = false;\n\n  constructor(data: ERC721TokenInput) {\n    this.contractAddress = data.address;\n    this.name = data.name;\n    this.symbol = data.symbol;\n    this.data = data;\n    //@ts-ignore\n    this.contract = new web3.eth.Contract(ERC721Abi.abi, this.contractAddress);\n    this.updateSupports();\n  }\n\n  async updateSupports() {\n    try {\n      const metadata = await this.contract.methods\n        .supportsInterface(ERC721MetadataID)\n        .call();\n      const enumerable = await this.contract.methods\n        .supportsInterface(ERC721EnumerableID)\n        .call();\n      this.canSupport = metadata && enumerable;\n    } catch (err) {\n      this.canSupport = false;\n    }\n  }\n\n  async getBalance(address: string) {\n    return await this.contract.methods.balanceOf(address).call();\n  }\n\n  async getAllTokensIds(address: string): Promise<string[]> {\n    if (!this.canSupport) return [];\n\n    const bal = await this.getBalance(address);\n    const res = [];\n    for (let i = 0; i < bal; i++) {\n      const tokenId = await this.contract.methods\n        .tokenOfOwnerByIndex(address, i)\n        .call();\n      res.push(tokenId);\n    }\n    return res;\n  }\n\n  async getAllTokenData(address: string) {\n    const ids = await this.getAllTokensIds(address);\n\n    const res = [];\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const data = await this.getTokenURI(parseInt(id));\n      res.push(data);\n    }\n    return res;\n  }\n\n  createTransferTx(from: string, to: string, id: string) {\n    return this.contract.methods.transferFrom(from, to, id);\n  }\n\n  async getTokenURI(id: number) {\n    if (this.tokenCache[id]) return this.tokenCache[id];\n    const data = await this.contract.methods.tokenURI(id).call();\n    this.tokenCache[id] = data;\n    return data;\n  }\n\n  async getTokenURIData(id: number): Promise<any> {\n    //Check cache\n    if (this.uriDataCache[id]) return this.uriDataCache[id];\n    const uri = await this.getTokenURI(id);\n    if (!uri) return null;\n    const res = (await axios.get(uri)).data;\n    //Save to cache\n    this.uriDataCache[id] = res;\n    return res;\n  }\n}\n\nexport default ERC721Token;\n","import axios from \"axios\";\n\nlet network_id: number = 0;\n\nclass AvaNetwork {\n  name: string;\n  id: number;\n  protocol: string;\n  port: number;\n  ip: string;\n  networkId: number;\n  // chainId: string;\n  url: string;\n  explorerUrl: string | undefined;\n  explorerSiteUrl: string | undefined;\n  readonly: boolean;\n  withCredentials = false;\n  // fee: BN\n\n  constructor(\n    name: string,\n    url: string,\n    networkId: number,\n    explorerUrl?: string,\n    explorerSiteUrl?: string,\n    readonly = false\n  ) {\n    this.id = network_id++;\n    this.name = name;\n    this.explorerUrl = explorerUrl;\n    this.explorerSiteUrl = explorerSiteUrl;\n    this.protocol = \"http\";\n    this.port = 9650;\n    this.ip = \"127.0.0.1\";\n    this.url = url;\n    this.updateURL(url);\n    this.networkId = networkId;\n    // this.chainId = chainId;\n    this.readonly = readonly;\n    // this.fee = new BN(0);\n  }\n\n  async testConnection(credentials = false) {\n    const resp = await axios\n      .post(\n        this.url + \"/ext/info\",\n        {\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"info.getNetworkID\",\n        },\n        {\n          withCredentials: true,\n        }\n      )\n      .catch((err) => {\n        return false;\n      });\n\n    return true;\n  }\n\n  // Checks if this network endpoint allows credentials\n  async updateCredentials() {\n    try {\n      const res = await axios.post(\n        this.url + \"/ext/info\",\n        {\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"info.getNetworkID\",\n        },\n        {\n          withCredentials: true,\n        }\n      );\n      this.withCredentials = true;\n    } catch (e) {\n      this.withCredentials = false;\n    }\n  }\n\n  updateURL(url: string) {\n    const split: string[] = url.split(\"://\");\n\n    this.protocol = split[0];\n\n    // port is set\n    if (split[1].includes(\":\")) {\n      const urlSplit: string[] = split[1].split(\":\");\n      const ip: string = urlSplit[0];\n      const port: string = urlSplit[1];\n\n      this.ip = ip;\n      this.port = parseInt(port);\n    } else {\n      this.ip = split[1];\n      if (this.protocol === \"http\") {\n        this.port = 9650;\n      } else {\n        this.port = 443;\n      }\n    }\n  }\n  getFullURL() {\n    return `${this.protocol}://${this.ip}:${this.port}`;\n  }\n\n  getWsUrlX(): string {\n    const protocol = this.protocol === \"https\" ? \"wss\" : \"ws\";\n    return `${protocol}://${this.ip}:${this.port}/ext/bc/V/events`;\n  }\n\n  getWsUrlC(): string {\n    const protocol = this.protocol === \"https\" ? \"wss\" : \"ws\";\n    return `${protocol}://${this.ip}:${this.port}/ext/bc/U/ws`;\n  }\n}\n\nexport { AvaNetwork };\n","import { TokenListToken } from \"@/store/modules/assets/types\";\nimport { web3 } from \"@/evm\";\nimport { BN } from \"avalanche\";\nimport { bnToBig } from \"@/helpers/helper\";\nimport Big from \"big.js\";\nimport store from \"@/store\";\n\nimport ERC20Abi from \"@openzeppelin/contracts/build/contracts/ERC20.json\";\n\nclass Erc20Token {\n  data: TokenListToken;\n  contract: any;\n  balanceRaw: string;\n  balanceBN: BN;\n  balanceBig: Big;\n\n  constructor(tokenData: TokenListToken) {\n    this.data = tokenData;\n    this.balanceRaw = \"0\";\n    this.balanceBN = new BN(\"0\");\n    this.balanceBig = Big(0);\n\n    //@ts-ignore\n    const tokenInst = new web3.eth.Contract(ERC20Abi.abi, tokenData.address);\n    this.contract = tokenInst;\n  }\n\n  // Returns a new instance of the token, given only the erc20 address\n  static fromAddress(address: string) {\n    //@ts-ignore\n    const tokenInst = new web3.eth.Contract(ERC20Abi.abi, address);\n    console.log(tokenInst);\n  }\n\n  createTransferTx(to: string, amount: BN) {\n    return this.contract.methods.transfer(to, amount.toString());\n  }\n\n  async updateBalance(address: string) {\n    const bal = await this.contract.methods.balanceOf(\"0x\" + address).call();\n    this.balanceRaw = bal;\n    this.balanceBN = new BN(bal);\n    this.balanceBig = bnToBig(\n      this.balanceBN,\n      parseInt(this.data.decimals as string)\n    );\n  }\n}\n\nexport default Erc20Token;\n","import { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { BN, Buffer } from \"avalanche\";\nimport {\n  AssetAmountDestination,\n  BaseTx,\n  MinterSet,\n  NFTMintOutput,\n  TransferableInput,\n  TransferableOutput,\n  UnsignedTx as AVMUnsignedTx,\n  UTXO as AVMUTXO,\n  UTXOSet,\n  UTXOSet as AVMUTXOSet,\n  AVMConstants,\n} from \"avalanche/dist/apis/avm\";\n\nimport { PayloadBase } from \"avalanche/dist/utils\";\nimport { OutputOwners } from \"avalanche/dist/common\";\nimport { PlatformVMConstants } from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  UnsignedTx as EVMUnsignedTx,\n  EVMConstants,\n} from \"avalanche/dist/apis/evm\";\n\nimport { web3 } from \"@/evm\";\nimport ERC721Token from \"@/js/ERC721Token\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport EthereumjsCommon from \"@ethereumjs/common\";\nimport Erc20Token from \"@/js/Erc20Token\";\n\nexport async function buildUnsignedTransaction(\n  orders: (ITransaction | AVMUTXO)[],\n  addr: string,\n  derivedAddresses: string[],\n  utxoset: AVMUTXOSet,\n  changeAddress?: string,\n  memo?: Buffer\n) {\n  // TODO: Get new change index.\n  if (!changeAddress) {\n    throw \"Unable to issue transaction. Ran out of change index.\";\n  }\n\n  const fromAddrsStr: string[] = derivedAddresses;\n  const fromAddrs: Buffer[] = fromAddrsStr.map((val) =>\n    bintools.parseAddress(val, \"V\")\n  );\n  const changeAddr: Buffer = bintools.stringToAddress(changeAddress);\n\n  // TODO: use internal asset ID\n  // This does not update on network change, causing issues\n  const DJTX_ID_BUF = await avm.getDJTXAssetID();\n  const DJTX_ID_STR = DJTX_ID_BUF.toString(\"hex\");\n  const TO_BUF = bintools.stringToAddress(addr);\n\n  const aad: AssetAmountDestination = new AssetAmountDestination(\n    [TO_BUF],\n    fromAddrs,\n    [changeAddr]\n  );\n  const ZERO = new BN(0);\n  let isFeeAdded = false;\n\n  // Aggregate Fungible ins & outs\n  for (let i: number = 0; i < orders.length; i++) {\n    const order: ITransaction | AVMUTXO = orders[i];\n\n    if ((order as ITransaction).asset) {\n      // if fungible\n      const tx: ITransaction = order as ITransaction;\n\n      const assetId = bintools.cb58Decode(tx.asset.id);\n      const amt: BN = tx.amount;\n\n      if (assetId.toString(\"hex\") === DJTX_ID_STR) {\n        aad.addAssetAmount(assetId, amt, avm.getTxFee());\n        isFeeAdded = true;\n      } else {\n        aad.addAssetAmount(assetId, amt, ZERO);\n      }\n    }\n  }\n\n  // If fee isn't added, add it\n  if (!isFeeAdded) {\n    if (avm.getTxFee().gt(ZERO)) {\n      aad.addAssetAmount(DJTX_ID_BUF, ZERO, avm.getTxFee());\n    }\n  }\n\n  const success: Error = utxoset.getMinimumSpendable(aad);\n\n  let ins: TransferableInput[] = [];\n  let outs: TransferableOutput[] = [];\n  if (typeof success === \"undefined\") {\n    ins = aad.getInputs();\n    outs = aad.getAllOutputs();\n  } else {\n    throw success;\n  }\n\n  //@ts-ignore\n  const nftUtxos: UTXO[] = orders.filter((val) => {\n    if ((val as ITransaction).asset) return false;\n    return true;\n  });\n\n  // If transferring an NFT, build the transaction on top of an NFT tx\n  let unsignedTx: AVMUnsignedTx;\n  const networkId: number = ava.getNetworkID();\n  const chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID());\n\n  if (nftUtxos.length > 0) {\n    const nftSet = new AVMUTXOSet();\n    nftSet.addArray(nftUtxos);\n\n    const utxoIds: string[] = nftSet.getUTXOIDs();\n\n    // Sort nft utxos\n    utxoIds.sort((a, b) => {\n      if (a < b) {\n        return -1;\n      } else if (a > b) {\n        return 1;\n      }\n      return 0;\n    });\n\n    unsignedTx = nftSet.buildNFTTransferTx(\n      networkId,\n      chainId,\n      [TO_BUF],\n      fromAddrs,\n      fromAddrs, // change address should be something else?\n      utxoIds,\n      undefined,\n      undefined,\n      memo\n    );\n\n    const rawTx = unsignedTx.getTransaction();\n    const outsNft = rawTx.getOuts();\n    const insNft = rawTx.getIns();\n\n    // TODO: This is a hackish way of doing this, need methods in avalanche.js\n    //@ts-ignore\n    rawTx.outs = outsNft.concat(outs);\n    //@ts-ignore\n    rawTx.ins = insNft.concat(ins);\n  } else {\n    const baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo);\n    unsignedTx = new AVMUnsignedTx(baseTx);\n  }\n  return unsignedTx;\n}\n\nexport async function buildCreateNftFamilyTx(\n  name: string,\n  symbol: string,\n  groupNum: number,\n  fromAddrs: string[],\n  minterAddr: string,\n  changeAddr: string,\n  utxoSet: UTXOSet\n) {\n  const fromAddresses = fromAddrs;\n  const changeAddress = changeAddr;\n  const minterAddress = minterAddr;\n\n  const minterSets: MinterSet[] = [];\n\n  // Create the groups\n  for (let i = 0; i < groupNum; i++) {\n    const minterSet: MinterSet = new MinterSet(1, [minterAddress]);\n    minterSets.push(minterSet);\n  }\n\n  const unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n    utxoSet,\n    fromAddresses,\n    [changeAddress],\n    minterSets,\n    name,\n    symbol\n  );\n  return unsignedTx;\n}\n\nexport async function buildMintNftTx(\n  mintUtxo: AVMUTXO,\n  payload: PayloadBase,\n  quantity: number,\n  ownerAddress: string,\n  changeAddress: string,\n  fromAddresses: string[],\n  utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n  const addrBuf = bintools.parseAddress(ownerAddress, \"V\");\n  const owners = [];\n\n  const sourceAddresses = fromAddresses;\n\n  for (let i = 0; i < quantity; i++) {\n    const owner = new OutputOwners([addrBuf]);\n    owners.push(owner);\n  }\n\n  const groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID();\n\n  const mintTx = await avm.buildCreateNFTMintTx(\n    utxoSet,\n    owners,\n    sourceAddresses,\n    [changeAddress],\n    mintUtxo.getUTXOID(),\n    groupID,\n    payload\n  );\n  return mintTx;\n}\n\nexport async function buildEvmTransferNativeTx(\n  from: string,\n  to: string,\n  amount: BN, // in wei\n  gasPrice: BN,\n  gasLimit: number\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      to: to,\n      value: amount,\n      data: \"0x\",\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport async function buildEvmTransferErc20Tx(\n  from: string,\n  to: string,\n  amount: BN, // in wei\n  gasPrice: BN,\n  gasLimit: number,\n  token: Erc20Token\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tokenTx = token.createTransferTx(to, amount);\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      value: \"0x0\",\n      to: token.data.address,\n      data: tokenTx.encodeABI(),\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport async function buildEvmTransferErc721Tx(\n  from: string,\n  to: string,\n  gasPrice: BN,\n  gasLimit: number,\n  token: ERC721Token,\n  tokenId: string\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tokenTx = token.createTransferTx(from, to, tokenId);\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      value: \"0x0\",\n      to: token.data.address,\n      data: tokenTx.encodeABI(),\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport enum AvmTxNameEnum {\n  \"Transaction\" = AVMConstants.BASETX,\n  \"Mint\" = AVMConstants.CREATEASSETTX,\n  \"Operation\" = AVMConstants.OPERATIONTX,\n  \"Import\" = AVMConstants.IMPORTTX,\n  \"Export\" = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n  \"Transaction\" = PlatformVMConstants.BASETX,\n  \"Add Validator\" = PlatformVMConstants.ADDVALIDATORTX,\n  \"Add Delegator\" = PlatformVMConstants.ADDDELEGATORTX,\n  \"Import\" = PlatformVMConstants.IMPORTTX,\n  \"Export\" = PlatformVMConstants.EXPORTTX,\n  \"Add Subnet Validator\" = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n  \"Create Chain\" = PlatformVMConstants.CREATECHAINTX,\n  \"Create Subnet\" = PlatformVMConstants.CREATESUBNETTX,\n  \"Advance Time\" = PlatformVMConstants.ADVANCETIMETX,\n  \"Reward Validator\" = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n  \"Transaction\" = AVMConstants.BASETX,\n  \"Import\" = AVMConstants.IMPORTTX,\n  \"Export\" = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n  \"Transaction\" = PlatformVMConstants.BASETX,\n  \"Add Validator\" = PlatformVMConstants.ADDVALIDATORTX,\n  \"Add Delegator\" = PlatformVMConstants.ADDDELEGATORTX,\n  \"Import\" = PlatformVMConstants.IMPORTTX,\n  \"Export\" = PlatformVMConstants.EXPORTTX,\n}\n\nexport enum ParseableEvmTxEnum {\n  \"Import\" = EVMConstants.IMPORTTX,\n  \"Export\" = EVMConstants.EXPORTTX,\n}\n","import { Buffer } from \"buffer/\";\nimport createHash from \"create-hash\";\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n  protected ivSize: number = 12;\n\n  protected saltSize: number = 16;\n\n  protected tagLength: number = 128;\n\n  protected aesLength: number = 256;\n\n  public keygenIterations: number = 200000; //3.0, 2.0 uses 100000\n\n  /**\n   * Internal-intended function for cleaning passwords.\n   *\n   * @param password\n   * @param salt\n   */\n  _pwcleaner(password: string, slt: Buffer): Buffer {\n    const pw: Buffer = Buffer.from(password, \"utf8\");\n    return this.sha256(Buffer.concat([pw, slt]));\n  }\n  /**\n   * Internal-intended function for producing an intermediate key.\n   *\n   * @param pwkey\n   */\n\n  async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n    return window.crypto.subtle.importKey(\n      \"raw\",\n      new Uint8Array(pwkey),\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveKey\"]\n    );\n  }\n\n  /**\n   * Internal-intended function for turning an intermediate key into a salted key.\n   *\n   * @param keyMaterial\n   * @param salt\n   */\n  async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n    return window.crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt,\n        iterations: this.keygenIterations,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: this.aesLength },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n  }\n\n  /**\n   * A SHA256 helper function.\n   *\n   * @param message The message to hash\n   *\n   * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n   */\n  sha256(message: string | Buffer): Buffer {\n    let buff: Buffer;\n    if (typeof message === \"string\") {\n      buff = Buffer.from(message, \"utf8\");\n    } else {\n      buff = Buffer.from(message);\n    }\n    return Buffer.from(createHash(\"sha256\").update(buff).digest()); // ensures correct Buffer class is used\n  }\n\n  /**\n   * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n   */\n  makeSalt(): Buffer {\n    const salt = Buffer.alloc(this.saltSize);\n    window.crypto.getRandomValues(salt);\n    return salt;\n  }\n\n  /**\n   * Produces a password-safe hash.\n   *\n   * @param password A string for the password\n   * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n   *\n   * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n   */\n  async pwhash(\n    password: string,\n    salt: Buffer\n  ): Promise<{ salt: Buffer; hash: Buffer }> {\n    let slt: Buffer;\n    if (salt instanceof Buffer) {\n      slt = salt;\n      // @ts-ignore\n    } else if (salt instanceof Uint8Array && process.env.NODE_ENV === \"test\") {\n      slt = salt;\n    } else {\n      slt = this.makeSalt();\n    }\n\n    const hash: Buffer = this._pwcleaner(\n      password,\n      this._pwcleaner(password, slt)\n    );\n    return { salt: slt, hash };\n  }\n\n  /**\n   * Encrypts plaintext with the provided password using AES-GCM.\n   *\n   * @param password A string for the password\n   * @param plaintext The plaintext to encrypt\n   * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n   *\n   * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n   */\n  async encrypt(\n    password: string,\n    plaintext: Buffer | string,\n    salt: Buffer | undefined = undefined\n  ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n    let slt: Buffer;\n    if (typeof salt !== \"undefined\" && salt instanceof Buffer) {\n      slt = salt;\n    } else {\n      slt = this.makeSalt();\n    }\n\n    let pt: Buffer;\n    if (typeof plaintext !== \"undefined\" && plaintext instanceof Buffer) {\n      pt = plaintext;\n    } else {\n      pt = Buffer.from(plaintext, \"utf8\");\n    }\n    const pwkey: Buffer = this._pwcleaner(password, slt);\n    const keyMaterial: CryptoKey = await this._keyMaterial(pwkey);\n    const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt);\n    const iv: Buffer = Buffer.from(\n      window.crypto.getRandomValues(new Uint8Array(this.ivSize))\n    );\n\n    const ciphertext: Buffer = Buffer.from(\n      await window.crypto.subtle.encrypt(\n        {\n          name: \"AES-GCM\",\n          iv,\n          additionalData: slt,\n          tagLength: this.tagLength,\n        },\n        pkey,\n        pt\n      )\n    );\n\n    return {\n      salt: slt,\n      iv,\n      ciphertext,\n    };\n  }\n\n  /**\n   * Decrypts ciphertext with the provided password, iv, and salt.\n   *\n   * @param password A string for the password\n   * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n   * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n   * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n   */\n  async decrypt(\n    password: string,\n    ciphertext: Buffer,\n    salt: Buffer,\n    iv: Buffer\n  ): Promise<Buffer> {\n    const pwkey: Buffer = this._pwcleaner(password, salt);\n    const keyMaterial: CryptoKey = await this._keyMaterial(pwkey);\n    const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt);\n\n    const pt: Buffer = Buffer.from(\n      await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv, // The initialization vector you used to encrypt\n          additionalData: salt, // The addtionalData you used to encrypt (if any)\n          tagLength: 128, // The tagLength you used to encrypt (if any)\n        },\n        pkey, // from generateKey or importKey above\n        ciphertext // ArrayBuffer of the data\n      )\n    );\n    return pt;\n  }\n\n  constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n  AllKeyFileDecryptedTypes,\n  AllKeyFileTypes,\n  KeyFileDecryptedV2,\n  KeyFileDecryptedV3,\n  KeyFileDecryptedV4,\n  KeyFileDecryptedV5,\n  KeyFileDecryptedV6,\n  KeyFileKeyDecryptedV2,\n  KeyFileKeyDecryptedV3,\n  KeyFileKeyDecryptedV4,\n  KeyFileKeyDecryptedV5,\n  KeyFileKeyDecryptedV6,\n  KeyFileKeyV2,\n  KeyFileKeyV3,\n  KeyFileKeyV4,\n  KeyFileKeyV5,\n  KeyFileKeyV6,\n  KeyFileV2,\n  KeyFileV3,\n  KeyFileV4,\n  KeyFileV5,\n  KeyFileV6,\n  KeystoreFileKeyType,\n} from \"./IKeystore\";\nimport { avm, bintools } from \"@/AVA\";\nimport { Buffer } from \"buffer/\";\nimport MnemonicWallet from \"@/js/wallets/MnemonicWallet\";\nimport Crypto from \"@/js/Crypto\";\nimport { SingletonWallet } from \"@/js/wallets/SingletonWallet\";\nimport { AccessWalletMultipleInput } from \"@/store/types\";\nimport { keyToKeypair } from \"@/helpers/helper\";\nimport * as bip39 from \"bip39\";\nimport { Buffer as AjsBuffer } from \"avalanche\";\n\nconst cryptoHelpers = new Crypto();\n\nconst KEYSTORE_VERSION: string = \"6.0\";\n\nconst ITERATIONS_V2 = 100000;\nconst ITERATIONS_V3 = 200000; // and any version above\n\nconst SUPPORTED_VERSION = [\"2.0\", \"3.0\", \"4.0\", \"5.0\", \"6.0\"];\n\ninterface IHash {\n  salt: Buffer;\n  hash: Buffer;\n}\n\ninterface PKCrypt {\n  salt: Buffer;\n  iv: Buffer;\n  ciphertext: Buffer;\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V2;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV2[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV2[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV2 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV3[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV3[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV3 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\nasync function readV4(\n  data: KeyFileV4,\n  pass: string\n): Promise<KeyFileDecryptedV5> {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV4[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV4[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV4 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readV5(\n  data: KeyFileV5,\n  pass: string\n): Promise<KeyFileDecryptedV5> {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV5[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV5[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV5 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = key_decrypt.toString();\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readV6(\n  data: KeyFileV6,\n  pass: string\n): Promise<KeyFileDecryptedV6> {\n  const version: string = data.version;\n  const activeIndex = data.activeIndex;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n\n  const keys: KeyFileKeyV6[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV6[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV6 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const type: KeystoreFileKeyType = key_data.type;\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    let key_decrypt: Buffer;\n    try {\n      key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce);\n    } catch (e) {\n      throw \"INVALID_PASS\";\n    }\n\n    const key_string = key_decrypt.toString();\n\n    keysDecrypt.push({\n      key: key_string,\n      type: type,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: activeIndex || 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readKeyFile(\n  data: AllKeyFileTypes,\n  pass: string\n): Promise<AllKeyFileDecryptedTypes> {\n  switch (data.version) {\n    case \"6.0\":\n      return await readV6(data as KeyFileV6, pass);\n    case \"5.0\":\n      return await readV5(data as KeyFileV5, pass);\n    case \"4.0\":\n      return await readV4(data as KeyFileV4, pass);\n    case \"3.0\":\n      return await readV3(data as KeyFileV3, pass);\n    case \"2.0\":\n      return await readV2(data as KeyFileV2, pass);\n    default:\n      throw \"INVALID_VERSION\";\n  }\n}\n\nfunction extractKeysV2(\n  file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n  const chainID = avm.getBlockchainAlias();\n  const keys = (file as\n    | KeyFileDecryptedV2\n    | KeyFileDecryptedV3\n    | KeyFileDecryptedV4).keys;\n\n  return keys.map((key) => {\n    // Private keys from the keystore file do not have the PrivateKey- prefix\n    const pk = \"PrivateKey-\" + key.key;\n    const keypair = keyToKeypair(pk, chainID);\n\n    const keyBuf = keypair.getPrivateKey();\n    const keyHex: string = keyBuf.toString(\"hex\");\n    const paddedKeyHex = keyHex.padStart(64, \"0\");\n    const mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex);\n\n    return {\n      key: mnemonic,\n      type: \"mnemonic\",\n    };\n  });\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    key: key.key,\n    type: \"mnemonic\",\n  }));\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    type: key.type,\n    key: key.key,\n  }));\n}\n\nfunction extractKeysFromDecryptedFile(\n  file: AllKeyFileDecryptedTypes\n): AccessWalletMultipleInput[] {\n  switch (file.version) {\n    case \"6.0\":\n      return extractKeysV6(file as KeyFileDecryptedV6);\n    case \"5.0\":\n      return extractKeysV5(file as KeyFileDecryptedV5);\n    case \"4.0\":\n      return extractKeysV2(file as KeyFileDecryptedV4);\n    case \"3.0\":\n      return extractKeysV2(file as KeyFileDecryptedV3);\n    case \"2.0\":\n      return extractKeysV2(file as KeyFileDecryptedV2);\n    default:\n      throw \"INVALID_VERSION\";\n  }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n  wallets: (MnemonicWallet | SingletonWallet)[],\n  pass: string,\n  activeIndex: number\n): Promise<KeyFileV6> {\n  // 3.0 and above uses 200,000\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = await cryptoHelpers.makeSalt();\n\n  const keys: KeyFileKeyV6[] = [];\n\n  for (let i: number = 0; i < wallets.length; i++) {\n    const wallet = wallets[i];\n    let key;\n    let type: KeystoreFileKeyType;\n    if (wallet.type === \"singleton\") {\n      key = (wallet as SingletonWallet).key;\n      type = \"singleton\";\n    } else {\n      key = (wallet as MnemonicWallet).getMnemonic();\n      type = \"mnemonic\";\n    }\n    const pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt);\n\n    const key_data: KeyFileKeyV6 = {\n      key: bintools.cb58Encode(AjsBuffer.from(pk_crypt.ciphertext)),\n      iv: bintools.cb58Encode(AjsBuffer.from(pk_crypt.iv)),\n      type: type,\n    };\n    keys.push(key_data);\n  }\n\n  const file_data: KeyFileV6 = {\n    version: KEYSTORE_VERSION,\n    salt: bintools.cb58Encode(AjsBuffer.from(salt)),\n    activeIndex,\n    keys: keys,\n  };\n  return file_data;\n}\n\nexport {\n  readKeyFile,\n  makeKeyfile,\n  KEYSTORE_VERSION,\n  extractKeysFromDecryptedFile,\n};\n","import {\n  KeyChain as AVMKeyChain,\n  KeyPair as AVMKeyPair,\n  UTXOSet as AVMUTXOSet,\n} from \"avalanche/dist/apis/avm\";\n\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm\";\nimport { getPreferredHRP } from \"avalanche/dist/utils\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport HDKey from \"hdkey\";\nimport { Buffer } from \"avalanche\";\nimport {\n  KeyChain as PlatformVMKeyChain,\n  KeyPair as PlatformVMKeyPair,\n} from \"avalanche/dist/apis/platformvm\";\nimport store from \"@/store\";\n\nimport { getAddressChains } from \"@/explorer_api\";\nimport { AvaNetwork } from \"@/js/AvaNetwork\";\nimport { ChainAlias } from \"./wallets/types\";\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from \"@/helpers/utxo_helper\";\nimport { updateFilterAddresses } from \"../providers\";\n\nconst INDEX_RANGE: number = 20; // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100; // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE; // How many items are actually scanned\nclass HdHelper {\n  chainId: ChainAlias;\n  keyChain: AVMKeyChain | PlatformVMKeyChain;\n  keyCache: {\n    [index: number]: AVMKeyPair | PlatformVMKeyPair;\n  };\n  addressCache: {\n    [index: number]: string;\n  };\n  hdCache: {\n    [index: number]: HDKey;\n  };\n  changePath: string;\n  masterKey: HDKey;\n  hdIndex: number;\n  utxoSet: AVMUTXOSet | PlatformUTXOSet;\n  isPublic: boolean;\n  isFetchUtxo: boolean; // true if updating balance\n  isInit: boolean; // true if HD index is found\n\n  constructor(\n    changePath: string,\n    masterKey: HDKey,\n    chainId: ChainAlias = \"V\",\n    isPublic: boolean = false\n  ) {\n    this.changePath = changePath;\n    this.isFetchUtxo = false;\n    this.isInit = false;\n\n    this.chainId = chainId;\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    if (chainId === \"V\") {\n      this.keyChain = new AVMKeyChain(hrp, chainId);\n      this.utxoSet = new AVMUTXOSet();\n    } else {\n      this.keyChain = new PlatformVMKeyChain(hrp, chainId);\n      this.utxoSet = new PlatformUTXOSet();\n    }\n\n    this.keyCache = {};\n    this.addressCache = {};\n    this.hdCache = {};\n    this.masterKey = masterKey;\n    this.hdIndex = 0;\n    this.isPublic = isPublic;\n    // this.oninit()\n  }\n\n  async oninit() {\n    await this.findHdIndex();\n  }\n\n  // When the wallet connects to a different network\n  // Clear internal data and scan again\n  async onNetworkChange() {\n    this.clearCache();\n    this.isInit = false;\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    if (this.chainId === \"V\") {\n      this.keyChain = new AVMKeyChain(hrp, this.chainId);\n      this.utxoSet = new AVMUTXOSet();\n    } else {\n      this.keyChain = new PlatformVMKeyChain(hrp, this.chainId);\n      this.utxoSet = new PlatformUTXOSet();\n    }\n    this.hdIndex = 0;\n    await this.oninit();\n  }\n\n  // Increments the hd index by one and adds the key\n  // returns the new keypair\n  incrementIndex(): number {\n    const newIndex: number = this.hdIndex + 1;\n\n    if (!this.isPublic) {\n      if (this.chainId === \"V\") {\n        const keychain = this.keyChain as AVMKeyChain;\n        const newKey = this.getKeyForIndex(newIndex) as AVMKeyPair;\n        keychain.addKey(newKey);\n      } else {\n        const keychain = this.keyChain as PlatformVMKeyChain;\n        const newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair;\n        keychain.addKey(newKey);\n      }\n    }\n\n    this.hdIndex = newIndex;\n\n    // Update websocket addresses with the new one\n    updateFilterAddresses();\n\n    return newIndex;\n  }\n\n  async findHdIndex() {\n    // Check if explorer is available\n\n    // @ts-ignore\n    const network: AvaNetwork = store.state.Network.selectedNetwork;\n    const explorerUrl = network.explorerUrl;\n\n    if (explorerUrl) {\n      this.hdIndex = await this.findAvailableIndexExplorer();\n    } else {\n      this.hdIndex = await this.findAvailableIndexNode();\n    }\n\n    if (!this.isPublic) {\n      this.updateKeychain();\n    }\n    this.isInit = true;\n  }\n\n  // Fetches the utxos for the current keychain\n  // and increments the index if last index has a utxo\n  async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n    this.isFetchUtxo = true;\n\n    if (!this.isInit) {\n      console.error(\"HD Index not found yet.\");\n    }\n\n    const addrs: string[] = this.getAllDerivedAddresses();\n    let result: AVMUTXOSet | PlatformUTXOSet;\n\n    if (this.chainId === \"V\") {\n      result = await avmGetAllUTXOs(addrs);\n    } else {\n      result = await platformGetAllUTXOs(addrs);\n    }\n    this.utxoSet = result; // we can use local copy of utxos as cache for some functions\n\n    // If the hd index is full, increment\n    const currentAddr = this.getCurrentAddress();\n    const currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId);\n    const currentUtxos = result.getUTXOIDs([currentAddrBuf]);\n\n    if (currentUtxos.length > 0) {\n      this.incrementIndex();\n    }\n    this.isFetchUtxo = false;\n    return result;\n  }\n\n  // Returns more addresses than the current index\n  getExtendedAddresses() {\n    const hdIndex = this.hdIndex;\n    return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE);\n  }\n\n  // Not used?\n  getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n    return this.utxoSet;\n  }\n\n  // Updates the helper keychain to contain keys upto the HD Index\n  updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    let keychain: AVMKeyChain | PlatformVMKeyChain;\n\n    if (this.chainId === \"V\") {\n      keychain = new AVMKeyChain(hrp, this.chainId);\n    } else {\n      keychain = new PlatformVMKeyChain(hrp, this.chainId);\n    }\n\n    for (let i: number = 0; i <= this.hdIndex; i++) {\n      let key: AVMKeyPair | PlatformVMKeyPair;\n      if (this.chainId === \"V\") {\n        key = this.getKeyForIndex(i) as AVMKeyPair;\n        (keychain as AVMKeyChain).addKey(key);\n      } else {\n        key = this.getKeyForIndex(i) as PlatformVMKeyPair;\n        (keychain as PlatformVMKeyChain).addKey(key);\n      }\n    }\n    this.keyChain = keychain;\n    return keychain;\n  }\n\n  getKeychain() {\n    return this.keyChain;\n  }\n\n  // Returns all key pairs up to hd index\n  getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n    const set: AVMKeyPair[] | PlatformVMKeyPair[] = [];\n    for (let i = 0; i <= upTo; i++) {\n      if (this.chainId === \"V\") {\n        const key = this.getKeyForIndex(i) as AVMKeyPair;\n        (set as AVMKeyPair[]).push(key);\n      } else {\n        const key = this.getKeyForIndex(i) as PlatformVMKeyPair;\n        (set as PlatformVMKeyPair[]).push(key);\n      }\n    }\n    return set;\n  }\n\n  getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n    const res = [];\n    for (let i = start; i <= upTo; i++) {\n      const addr = this.getAddressForIndex(i);\n      res.push(addr);\n    }\n    return res;\n  }\n\n  clearCache() {\n    this.keyCache = {};\n    this.addressCache = {};\n  }\n\n  // Scans the address space of this hd path and finds the last used index using the\n  // explorer API.\n  async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n    const upTo = 512;\n\n    const addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex);\n    const addrChains = await getAddressChains(addrs);\n\n    let chainID;\n    if (this.chainId === \"V\") {\n      chainID = avm.getBlockchainID();\n    } else {\n      chainID = pChain.getBlockchainID();\n    }\n\n    for (let i = 0; i < addrs.length - INDEX_RANGE; i++) {\n      let gapSize: number = 0;\n\n      for (let n = 0; n < INDEX_RANGE; n++) {\n        const scanIndex = i + n;\n        const scanAddr = addrs[scanIndex];\n\n        const rawAddr = scanAddr.split(\"-\")[1];\n        const chains: string[] = addrChains[rawAddr];\n        if (!chains) {\n          // If doesnt exist on any chain\n          gapSize++;\n        } else if (!chains.includes(chainID)) {\n          // If doesnt exist on this chain\n          gapSize++;\n        } else {\n          i = i + n;\n          break;\n        }\n      }\n\n      // If the gap is reached return the index\n      if (gapSize === INDEX_RANGE) {\n        return startIndex + i;\n      }\n    }\n\n    return await this.findAvailableIndexExplorer(\n      startIndex + (upTo - INDEX_RANGE)\n    );\n  }\n\n  // Uses the node to find last used HD index\n  // Only used when there is no explorer API available\n  async findAvailableIndexNode(start: number = 0): Promise<number> {\n    const addrs: string[] = [];\n\n    // Get keys for indexes start to start+scan_size\n    for (let i: number = start; i < start + SCAN_SIZE; i++) {\n      const address = this.getAddressForIndex(i);\n      addrs.push(address);\n    }\n\n    let utxoSet;\n\n    if (this.chainId === \"V\") {\n      utxoSet = (await avm.getUTXOs(addrs)).utxos;\n    } else {\n      utxoSet = (await pChain.getUTXOs(addrs)).utxos;\n    }\n\n    // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n    for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n      let gapSize: number = 0;\n      // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n      for (let n: number = 0; n < INDEX_RANGE; n++) {\n        const scanIndex: number = i + n;\n        const addr: string = addrs[scanIndex];\n        const addrBuf = bintools.parseAddress(addr, this.chainId);\n        const addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf]);\n        if (addrUTXOs.length === 0) {\n          gapSize++;\n        } else {\n          // Potential improvement\n          i = i + n;\n          break;\n        }\n      }\n\n      // If we found a gap of 20, we can return the last fullIndex+1\n      if (gapSize === INDEX_RANGE) {\n        const targetIndex = start + i;\n        return targetIndex;\n      }\n    }\n    return await this.findAvailableIndexNode(start + SCAN_RANGE);\n  }\n\n  getFirstAvailableIndex(): number {\n    for (let i = 0; i < this.hdIndex; i++) {\n      const addr = this.getAddressForIndex(i);\n      const addrBuf = bintools.parseAddress(addr, this.chainId);\n      const utxoIds = this.utxoSet.getUTXOIDs([addrBuf]);\n      if (utxoIds.length === 0) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  // Returns the key of the first index that has no utxos\n  getFirstAvailableAddress(): string {\n    const idx = this.getFirstAvailableIndex();\n    return this.getAddressForIndex(idx);\n  }\n\n  getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n    const index: number = this.hdIndex;\n    return this.getKeyForIndex(index);\n  }\n\n  getCurrentAddress(): string {\n    const index = this.hdIndex;\n    return this.getAddressForIndex(index);\n  }\n\n  // TODO: Public wallet should never be using this\n  getKeyForIndex(\n    index: number,\n    isPrivate: boolean = true\n  ): AVMKeyPair | PlatformVMKeyPair {\n    // If key is cached return that\n    let cacheExternal: AVMKeyPair | PlatformVMKeyPair;\n\n    if (this.chainId === \"V\") {\n      cacheExternal = this.keyCache[index] as AVMKeyPair;\n    } else {\n      cacheExternal = this.keyCache[index] as PlatformVMKeyPair;\n    }\n\n    if (cacheExternal) return cacheExternal;\n\n    const derivationPath: string = `${this.changePath}/${index.toString()}`;\n\n    // Get key from cache, if not generate it\n    let key: HDKey;\n    if (this.hdCache[index]) {\n      key = this.hdCache[index];\n    } else {\n      key = this.masterKey.derive(derivationPath) as HDKey;\n      this.hdCache[index] = key;\n    }\n\n    let pkHex: string;\n    if (!this.isPublic) {\n      pkHex = key.privateKey.toString(\"hex\");\n    } else {\n      pkHex = key.publicKey.toString(\"hex\");\n    }\n\n    const pkBuf: Buffer = new Buffer(pkHex, \"hex\");\n    const keypair = this.keyChain.importKey(pkBuf);\n\n    // save to cache\n    this.keyCache[index] = keypair;\n    return keypair;\n  }\n\n  getAddressForIndex(index: number): string {\n    if (this.addressCache[index]) {\n      return this.addressCache[index];\n    }\n\n    const derivationPath: string = `${this.changePath}/${index.toString()}`;\n    // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n    // Get key from cache, if not generate it\n    let key: HDKey;\n    if (this.hdCache[index]) {\n      key = this.hdCache[index];\n    } else {\n      key = this.masterKey.derive(derivationPath) as HDKey;\n      this.hdCache[index] = key;\n    }\n\n    const pkHex = key.publicKey.toString(\"hex\");\n    const pkBuff = Buffer.from(pkHex, \"hex\");\n    const hrp = getPreferredHRP(ava.getNetworkID());\n\n    const chainId = this.chainId;\n\n    // No need for PlatformKeypair because addressToString uses chainID to decode\n    const keypair = new AVMKeyPair(hrp, chainId);\n    const addrBuf = AVMKeyPair.addressFromPublicKey(pkBuff);\n    const addr = bintools.addressToString(hrp, chainId, addrBuf);\n\n    this.addressCache[index] = addr;\n    return addr;\n  }\n\n  // Given an address find the derived index\n  findAddressIndex(addr: string): number | null {\n    const addrs = this.getAllDerivedAddresses();\n    const index = addrs.indexOf(addr);\n\n    if (index < 0) return null;\n    return index;\n  }\n}\nexport { HdHelper };\n","import { ChainAlias } from \"@/js/wallets/types\";\nimport { UTXO } from \"avalanche/dist/apis/avm\";\n\nimport { BN, Buffer } from \"avalanche\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { ava, avm, bintools, pChain } from \"@/AVA\";\nimport { UTXOSet as AVMUTXOSet } from \"avalanche/dist/apis/avm/utxos\";\nimport HDKey from \"hdkey\";\nimport { HdHelper } from \"@/js/HdHelper\";\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm/utxos\";\nimport {\n  buildCreateNftFamilyTx,\n  buildMintNftTx,\n  buildUnsignedTransaction,\n} from \"../TxHelper\";\nimport { WalletCore } from \"@/js/wallets/WalletCore\";\nimport { updateFilterAddresses } from \"../../providers\";\nimport { digestMessage } from \"@/helpers/helper\";\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nabstract class HdWalletCore extends WalletCore {\n  chainId: string;\n\n  internalHelper: HdHelper;\n  externalHelper: HdHelper;\n  platformHelper: HdHelper;\n\n  ethHdNode: HDKey;\n  protected accountNodeXP: HDKey;\n\n  constructor(accountHdKey: HDKey, ethHdNode: HDKey, isPublic = true) {\n    super();\n    this.ethHdNode = ethHdNode;\n    this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID();\n    this.externalHelper = new HdHelper(\n      \"m/0\",\n      accountHdKey,\n      undefined,\n      isPublic\n    );\n    this.internalHelper = new HdHelper(\n      \"m/1\",\n      accountHdKey,\n      undefined,\n      isPublic\n    );\n    this.platformHelper = new HdHelper(\"m/0\", accountHdKey, \"M\", isPublic);\n    this.accountNodeXP = accountHdKey;\n\n    this.externalHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n    this.internalHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n    this.platformHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n  }\n\n  getXpubXP() {\n    return this.accountNodeXP.toJSON().xpub;\n  }\n\n  getEvmAddressBech(): string {\n    return bintools.addressToString(\n      ava.getHRP(),\n      \"U\",\n      // @ts-ignore\n      this.ethHdNode.pubKeyHash\n    );\n  }\n\n  updateAvmUTXOSet(): void {\n    // if (this.isFetchUtxos) return\n    const setExternal = this.externalHelper.utxoSet as AVMUTXOSet;\n    const setInternal = this.internalHelper.utxoSet as AVMUTXOSet;\n\n    const joined = setInternal.merge(setExternal);\n    this.utxoset = joined;\n  }\n\n  getFirstAvailableAddressPlatform(): string {\n    return this.platformHelper.getFirstAvailableAddress();\n  }\n\n  updateFetchState() {\n    this.isFetchUtxos =\n      this.externalHelper.isFetchUtxo ||\n      this.internalHelper.isFetchUtxo ||\n      this.platformHelper.isFetchUtxo;\n  }\n\n  updateInitState() {\n    this.isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n\n    if (this.isInit) {\n      updateFilterAddresses();\n    }\n  }\n  // Fetches the utxos\n  async getUTXOs(): Promise<void> {\n    this.updateUTXOsX();\n\n    // platform utxos are updated but not returned by function\n    this.updateUTXOsP();\n\n    return;\n  }\n\n  async updateUTXOsX() {\n    this.updateUTXOsExternal();\n    this.updateUTXOsInternal();\n  }\n\n  async updateUTXOsExternal() {\n    const res = await this.externalHelper.updateUtxos();\n    this.updateFetchState();\n    this.updateAvmUTXOSet();\n  }\n\n  async updateUTXOsInternal() {\n    const utxoSet = await this.internalHelper.updateUtxos();\n    this.updateFetchState();\n    this.updateAvmUTXOSet();\n  }\n\n  async updateUTXOsP() {\n    const utxoSet = await this.platformHelper.updateUtxos();\n    this.updateFetchState();\n  }\n\n  getAllDerivedExternalAddresses(): string[] {\n    return this.externalHelper.getAllDerivedAddresses();\n  }\n\n  getDerivedAddresses(): string[] {\n    const internal = this.internalHelper.getAllDerivedAddresses();\n    const external = this.externalHelper.getAllDerivedAddresses();\n    return internal.concat(external);\n  }\n\n  getDerivedAddressesP(): string[] {\n    return this.platformHelper.getAllDerivedAddresses();\n  }\n\n  getAllAddressesX() {\n    return this.getDerivedAddresses();\n  }\n\n  getAllAddressesP() {\n    return this.getDerivedAddressesP();\n  }\n  // Returns addresses to check for history\n  getHistoryAddresses(): string[] {\n    const internalIndex = this.internalHelper.hdIndex;\n    // They share the same address space, so whatever has the highest index\n    const externalIndex = Math.max(\n      this.externalHelper.hdIndex,\n      this.platformHelper.hdIndex\n    );\n\n    const internal = this.internalHelper.getAllDerivedAddresses(internalIndex);\n    const external = this.externalHelper.getAllDerivedAddresses(externalIndex);\n    return internal.concat(external);\n  }\n\n  getCurrentAddressAvm(): string {\n    return this.externalHelper.getCurrentAddress();\n  }\n\n  getChangeAddressAvm() {\n    return this.internalHelper.getCurrentAddress();\n  }\n\n  getChangeAddressPlatform() {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getChangePath(chainId?: ChainAlias): string {\n    switch (chainId) {\n      case \"M\":\n        return this.platformHelper.changePath;\n      case \"V\":\n      default:\n        return this.internalHelper.changePath;\n    }\n  }\n\n  getChangeIndex(chainId?: ChainAlias): number {\n    switch (chainId) {\n      case \"M\":\n        return this.platformHelper.hdIndex;\n      case \"V\":\n      default:\n        return this.internalHelper.hdIndex;\n    }\n  }\n\n  getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n    if (idx === undefined || idx === null) return null;\n\n    switch (chainId) {\n      case \"M\":\n        return this.platformHelper.getAddressForIndex(idx);\n      case \"V\":\n      default:\n        return this.internalHelper.getAddressForIndex(idx);\n    }\n  }\n\n  getPlatformRewardAddress(): string {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getCurrentAddressPlatform(): string {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getPlatformUTXOSet() {\n    return this.platformHelper.utxoSet as PlatformUTXOSet;\n  }\n\n  getPlatformActiveIndex() {\n    return this.platformHelper.hdIndex;\n  }\n\n  getExternalActiveIndex() {\n    return this.externalHelper.hdIndex;\n  }\n\n  getBaseAddress() {\n    return this.externalHelper.getAddressForIndex(0);\n  }\n\n  onnetworkchange(): void {\n    this.isInit = false;\n    this.stakeAmount = new BN(0);\n\n    this.externalHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n    this.internalHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n    this.platformHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n\n    // TODO: Handle EVM changes\n  }\n\n  async buildUnsignedTransaction(\n    orders: (ITransaction | UTXO)[],\n    addr: string,\n    memo?: Buffer\n  ) {\n    const changeAddress = this.getChangeAddressAvm();\n    const derivedAddresses: string[] = this.getDerivedAddresses();\n    const utxoset = this.getUTXOSet();\n\n    return buildUnsignedTransaction(\n      orders,\n      addr,\n      derivedAddresses,\n      utxoset,\n      changeAddress,\n      memo\n    );\n  }\n\n  findExternalAddressIndex(address: string): number | null {\n    // TODO: Look for P addresses too\n    const indexX = this.externalHelper.findAddressIndex(address);\n    const indexP = this.platformHelper.findAddressIndex(address);\n\n    const index = indexX !== null ? indexX : indexP;\n\n    if (indexX === null && indexP === null)\n      throw new Error(\"Address not found.\");\n    return index;\n  }\n\n  async signMessageByExternalAddress(msgStr: string, address: string) {\n    const index = this.findExternalAddressIndex(address);\n    if (index === null) throw new Error(\"Address not found.\");\n    return await this.signMessageByExternalIndex(msgStr, index);\n  }\n\n  async signMessageByExternalIndex(\n    msgStr: string,\n    index: number\n  ): Promise<string> {\n    const digest = digestMessage(msgStr);\n\n    // Convert to the other Buffer and sign\n    const digestHex = digest.toString(\"hex\");\n    const digestBuff = Buffer.from(digestHex, \"hex\");\n\n    return await this.signHashByExternalIndex(index, digestBuff);\n  }\n\n  async signMessage(msg: string, address: string) {\n    return await this.signMessageByExternalAddress(msg, address);\n  }\n\n  abstract async signHashByExternalIndex(\n    index: number,\n    hash: Buffer\n  ): Promise<string>;\n}\nexport { HdWalletCore };\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppDjtx from \"@obsidiansystems/hw-app-avalanche\";\n//@ts-ignore\nimport Eth from \"@ledgerhq/hw-app-eth\";\n\nimport EthereumjsCommon from \"@ethereumjs/common\";\nimport { Transaction } from \"@ethereumjs/tx\";\n\nimport moment from \"moment\";\nimport { Buffer, BN } from \"avalanche\";\nimport HDKey from \"hdkey\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nconst bippath = require(\"bip32-path\");\nimport createHash from \"create-hash\";\nimport store from \"@/store\";\nimport { importPublic, publicToAddress, bnToRlp, rlp } from \"ethereumjs-util\";\n\nimport {\n  UTXO as AVMUTXO,\n  UTXO,\n  UTXOSet as AVMUTXOSet,\n} from \"avalanche/dist/apis/avm/utxos\";\nimport { AvaWalletCore } from \"@/js/wallets/types\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport {\n  AVMConstants,\n  OperationTx,\n  SelectCredentialClass as AVMSelectCredentialClass,\n  TransferableOperation,\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n  ImportTx as AVMImportTx,\n} from \"avalanche/dist/apis/avm\";\n\nimport {\n  ImportTx as PlatformImportTx,\n  ExportTx as PlatformExportTx,\n  Tx as PlatformTx,\n  UTXO as PlatformUTXO,\n  UnsignedTx as PlatformUnsignedTx,\n  PlatformVMConstants,\n  SelectCredentialClass as PlatformSelectCredentialClass,\n  AddDelegatorTx,\n  AddValidatorTx,\n} from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  UnsignedTx as EVMUnsignedTx,\n  ImportTx as EVMImportTx,\n  ExportTx as EVMExportTx,\n  Tx as EvmTx,\n  EVMConstants,\n  EVMInput,\n  SelectCredentialClass as EVMSelectCredentialClass,\n} from \"avalanche/dist/apis/evm\";\n\nimport {\n  Credential,\n  SigIdx,\n  Signature,\n  UTXOResponse,\n  Address,\n} from \"avalanche/dist/common\";\nimport { getPreferredHRP, PayloadBase } from \"avalanche/dist/utils\";\nimport { HdWalletCore } from \"@/js/wallets/HdWalletCore\";\nimport { ILedgerAppConfig } from \"@/store/types\";\nimport { WalletNameType } from \"@/js/wallets/types\";\nimport { abiDecoder, web3 } from \"@/evm\";\nimport {\n  AVA_ACCOUNT_PATH,\n  ETH_ACCOUNT_PATH,\n  LEDGER_ETH_ACCOUNT_PATH,\n} from \"./MnemonicWallet\";\nimport { ChainIdType } from \"@/constants\";\nimport {\n  ParseableAvmTxEnum,\n  ParseablePlatformEnum,\n  ParseableEvmTxEnum,\n} from \"../TxHelper\";\nimport { ILedgerBlockMessage } from \"../../store/modules/ledger/types\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { bnToBig, idToChainAlias } from \"@avalabs/avalanche-wallet-sdk\";\n\nexport const MIN_EVM_SUPPORT_V = \"0.5.3\";\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n  app: AppDjtx;\n  ethApp: Eth;\n  type: WalletNameType;\n\n  ethAddress: string;\n  ethBalance: BN;\n  config: ILedgerAppConfig;\n  ethHdNode: HDKey;\n\n  constructor(\n    app: AppDjtx,\n    hdkey: HDKey,\n    config: ILedgerAppConfig,\n    hdEth: HDKey,\n    ethApp: Eth\n  ) {\n    super(hdkey, hdEth);\n    this.app = app;\n    this.ethApp = ethApp;\n    this.type = \"ledger\";\n    this.config = config;\n    this.ethHdNode = hdEth;\n\n    if (hdEth) {\n      const ethKey = hdEth;\n      const ethPublic = importPublic(ethKey.publicKey);\n      this.ethAddress = publicToAddress(ethPublic).toString(\"hex\");\n      this.ethBalance = new BN(0);\n    } else {\n      this.ethAddress = \"\";\n      this.ethBalance = new BN(0);\n    }\n  }\n\n  static async fromApp(app: AppDjtx, eth: Eth, config: ILedgerAppConfig) {\n    const res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH);\n\n    const hd = new HDKey();\n    hd.publicKey = res.public_key;\n    hd.chainCode = res.chain_code;\n\n    const ethRes = await eth.getAddress(LEDGER_ETH_ACCOUNT_PATH, true, true);\n    const hdEth = new HDKey();\n    // @ts-ignore\n    hdEth.publicKey = Buffer.from(ethRes.publicKey, \"hex\");\n    // @ts-ignore\n    hdEth.chainCode = Buffer.from(ethRes.chainCode, \"hex\");\n\n    return new LedgerWallet(app, hd, config, hdEth, eth);\n  }\n\n  // Returns an array of derivation paths that need to sign this transaction\n  // Used with signTransactionHash and signTransactionParsable\n  getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType\n  ): { paths: string[]; isDjtxOnly: boolean } {\n    // TODO: This is a nasty fix. Remove when AJS is updated.\n    unsignedTx.toBuffer();\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    const ins = tx.getIns();\n    let operations: TransferableOperation[] = [];\n\n    // Try to get operations, it will fail if there are none, ignore and continue\n    try {\n      operations = (tx as OperationTx).getOperations();\n    } catch (e) {\n      console.log(e);\n    }\n\n    let items = ins;\n    if (\n      (txType === AVMConstants.IMPORTTX && chainId === \"V\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"M\")\n    ) {\n      items = ((tx as AVMImportTx) || PlatformImportTx).getImportInputs();\n    }\n\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    const paths: string[] = [];\n\n    let isDjtxOnly = true;\n\n    // Collect derivation paths for source addresses\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      const assetId = bintools.cb58Encode(item.getAssetID());\n      // @ts-ignore\n      if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n        isDjtxOnly = false;\n      }\n\n      const sigidxs: SigIdx[] = item.getInput().getSigIdxs();\n      const sources = sigidxs.map((sigidx) => sigidx.getSource());\n      const addrs: string[] = sources.map((source) => {\n        return bintools.addressToString(hrp, chainId, source);\n      });\n\n      for (let j = 0; j < addrs.length; j++) {\n        const srcAddr = addrs[j];\n        const pathStr = this.getPathFromAddress(srcAddr); // returns change/index\n\n        paths.push(pathStr);\n      }\n    }\n\n    // Do the Same for operational inputs, if there are any...\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i];\n      const sigidxs: SigIdx[] = op.getOperation().getSigIdxs();\n      const sources = sigidxs.map((sigidx) => sigidx.getSource());\n      const addrs: string[] = sources.map((source) => {\n        return bintools.addressToString(hrp, chainId, source);\n      });\n\n      for (let j = 0; j < addrs.length; j++) {\n        const srcAddr = addrs[j];\n        const pathStr = this.getPathFromAddress(srcAddr); // returns change/index\n\n        paths.push(pathStr);\n      }\n    }\n\n    return { paths, isDjtxOnly };\n  }\n\n  pathsToUniqueBipPaths(paths: string[]) {\n    const uniquePaths = paths.filter((val: any, i: number) => {\n      return paths.indexOf(val) === i;\n    });\n\n    const bip32Paths = uniquePaths.map((path) => {\n      return bippath.fromString(path, false);\n    });\n\n    return bip32Paths;\n  }\n\n  getChangeBipPath<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType) {\n    if (chainId === \"U\") {\n      return null;\n    }\n\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    const chainChangePath = this.getChangePath(chainId).split(\"m/\")[1];\n    let changeIdx = this.getChangeIndex(chainId);\n    // If change and destination paths are the same\n    // it can cause ledger to not display the destination amt.\n    // Since platform helper does not have internal/external\n    // path for change (it uses the next address)\n    // there can be an address collisions.\n    if (\n      (txType === PlatformVMConstants.IMPORTTX ||\n        txType === PlatformVMConstants.EXPORTTX) &&\n      this.platformHelper.hdIndex === this.externalHelper.hdIndex\n    ) {\n      return null;\n    } else if (\n      txType === PlatformVMConstants.ADDVALIDATORTX ||\n      txType === PlatformVMConstants.ADDDELEGATORTX\n    ) {\n      changeIdx = this.platformHelper.getFirstAvailableIndex();\n    }\n\n    return bippath.fromString(\n      `${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`\n    );\n  }\n\n  getCredentials<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    sigMap: any,\n    chainId: ChainIdType\n  ): Credential[] {\n    const creds: Credential[] = [];\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    // @ts-ignore\n    const ins = tx.getIns ? tx.getIns() : [];\n    let operations: TransferableOperation[] = [];\n    let evmInputs: EVMInput[] = [];\n\n    let items = ins;\n    if (\n      (txType === AVMConstants.IMPORTTX && chainId === \"V\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"M\") ||\n      (txType === EVMConstants.IMPORTTX && chainId === \"U\")\n    ) {\n      items = (\n        (tx as AVMImportTx) ||\n        PlatformImportTx ||\n        EVMImportTx\n      ).getImportInputs();\n    }\n\n    // Try to get operations, it will fail if there are none, ignore and continue\n    try {\n      operations = (tx as OperationTx).getOperations();\n    } catch (e) {\n      console.error(e);\n    }\n\n    let CredentialClass;\n    if (chainId === \"V\") {\n      CredentialClass = AVMSelectCredentialClass;\n    } else if (chainId === \"M\") {\n      CredentialClass = PlatformSelectCredentialClass;\n    } else {\n      CredentialClass = EVMSelectCredentialClass;\n    }\n\n    // Try to get evm inputs, it will fail if there are none, ignore and continue\n    try {\n      evmInputs = (tx as EVMExportTx).getInputs();\n    } catch (e) {\n      console.error(e);\n    }\n\n    for (let i = 0; i < items.length; i++) {\n      const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs();\n      const cred: Credential = CredentialClass(\n        items[i].getInput().getCredentialID()\n      );\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i].getOperation();\n      const sigidxs: SigIdx[] = op.getSigIdxs();\n      const cred: Credential = CredentialClass(op.getCredentialID());\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = items.length + i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    for (let i = 0; i < evmInputs.length; i++) {\n      const evmInput = evmInputs[i];\n      const sigidxs: SigIdx[] = evmInput.getSigIdxs();\n      const cred: Credential = CredentialClass(evmInput.getCredentialID());\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = items.length + i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    return creds;\n  }\n\n  // Used for non parsable transactions.\n  // Ideally we wont use this function at all, but ledger is not ready yet.\n  async signTransactionHash<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n    SignedTx extends AVMTx | PlatformTx | EvmTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    chainId: ChainIdType\n  ): Promise<SignedTx> {\n    const txbuff = unsignedTx.toBuffer();\n    const msg: Buffer = Buffer.from(\n      createHash(\"sha256\").update(txbuff).digest()\n    );\n\n    try {\n      store.commit(\"Ledger/openModal\", {\n        title: \"Sign Hash\",\n        messages: [],\n        info: msg.toString(\"hex\").toUpperCase(),\n      });\n\n      const bip32Paths = this.pathsToUniqueBipPaths(paths);\n\n      // Sign the msg with ledger\n      const accountPathSource =\n        chainId === \"U\" ? ETH_ACCOUNT_PATH : AVA_ACCOUNT_PATH;\n      const accountPath = bippath.fromString(`${accountPathSource}`);\n      const sigMap = await this.app.signHash(accountPath, bip32Paths, msg);\n      store.commit(\"Ledger/closeModal\");\n\n      const creds: Credential[] = this.getCredentials<UnsignedTx>(\n        unsignedTx,\n        paths,\n        sigMap,\n        chainId\n      );\n\n      let signedTx;\n      switch (chainId) {\n        case \"V\":\n          signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds);\n          break;\n        case \"M\":\n          signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds);\n          break;\n        case \"U\":\n          signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds);\n          break;\n      }\n\n      return signedTx as SignedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  // Used for signing transactions that are parsable\n  async signTransactionParsable<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n    SignedTx extends AVMTx | PlatformTx | EvmTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    chainId: ChainIdType\n  ): Promise<SignedTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const parseableTxs = {\n      V: ParseableAvmTxEnum,\n      M: ParseablePlatformEnum,\n      U: ParseableEvmTxEnum,\n    }[chainId];\n\n    const title = `Sign ${parseableTxs[txType]}`;\n\n    const bip32Paths = this.pathsToUniqueBipPaths(paths);\n\n    const accountPath =\n      chainId === \"U\"\n        ? bippath.fromString(`${ETH_ACCOUNT_PATH}`)\n        : bippath.fromString(`${AVA_ACCOUNT_PATH}`);\n    const txbuff = unsignedTx.toBuffer();\n    const changePath = this.getChangeBipPath(unsignedTx, chainId);\n    const messages = this.getTransactionMessages<UnsignedTx>(\n      unsignedTx,\n      chainId,\n      changePath\n    );\n\n    try {\n      store.commit(\"Ledger/openModal\", {\n        title: title,\n        messages: messages,\n        info: null,\n      });\n\n      const ledgerSignedTx = await this.app.signTransaction(\n        accountPath,\n        bip32Paths,\n        txbuff,\n        changePath\n      );\n\n      const sigMap = ledgerSignedTx.signatures;\n      const creds = this.getCredentials<UnsignedTx>(\n        unsignedTx,\n        paths,\n        sigMap,\n        chainId\n      );\n\n      let signedTx;\n      switch (chainId) {\n        case \"V\":\n          signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds);\n          break;\n        case \"M\":\n          signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds);\n          break;\n        case \"U\":\n          signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds);\n          break;\n      }\n\n      return signedTx as SignedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  getOutputMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType,\n    changePath: null | { toPathArray: () => number[] }\n  ): ILedgerBlockMessage[] {\n    const messages: ILedgerBlockMessage[] = [];\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    // @ts-ignore\n    let outs;\n    if (\n      (txType === AVMConstants.EXPORTTX && chainId === \"V\") ||\n      (txType === PlatformVMConstants.EXPORTTX && chainId === \"M\")\n    ) {\n      outs = (tx as PlatformExportTx).getExportOutputs();\n    } else if (txType === EVMConstants.EXPORTTX && chainId === \"U\") {\n      outs = (tx as EVMExportTx).getExportedOutputs();\n    } else {\n      outs = (tx as PlatformExportTx).getOuts();\n    }\n\n    let destinationChain = chainId;\n    if (chainId === \"U\" && txType === EVMConstants.EXPORTTX)\n      destinationChain = \"V\";\n\n    if (destinationChain === \"U\") {\n      for (let i = 0; i < outs.length; i++) {\n        // @ts-ignore\n        const value = outs[i].getAddress();\n        const addr = bintools.addressToString(hrp, chainId, value);\n        // @ts-ignore\n        const amt = bnToBig(outs[i].getAmount(), 9);\n\n        messages.push({\n          title: \"Output\",\n          value: `${addr} - ${amt.toString()} DJT`,\n        });\n      }\n    } else {\n      const changeIdx = changePath?.toPathArray()[\n        changePath?.toPathArray().length - 1\n      ];\n      const changeAddr = this.getChangeFromIndex(changeIdx, destinationChain);\n\n      for (let i = 0; i < outs.length; i++) {\n        outs[i]\n          .getOutput()\n          .getAddresses()\n          .forEach((value) => {\n            const addr = bintools.addressToString(hrp, chainId, value);\n            // @ts-ignore\n            const amt = bnToBig(outs[i].getOutput().getAmount(), 9);\n\n            if (!changePath || changeAddr !== addr)\n              messages.push({\n                title: \"Output\",\n                value: `${addr} - ${amt.toString()} DJT`,\n              });\n          });\n      }\n    }\n\n    return messages;\n  }\n\n  getValidateDelegateMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType): ILedgerBlockMessage[] {\n    const tx =\n      ((unsignedTx as\n        | AVMUnsignedTx\n        | PlatformUnsignedTx).getTransaction() as AddValidatorTx) ||\n      AddDelegatorTx;\n    const txType = tx.getTxType();\n    const messages: ILedgerBlockMessage[] = [];\n\n    if (\n      (txType === PlatformVMConstants.ADDDELEGATORTX && chainId === \"M\") ||\n      (txType === PlatformVMConstants.ADDVALIDATORTX && chainId === \"M\")\n    ) {\n      const format = \"YYYY-MM-DD H:mm:ss UTC\";\n\n      const nodeID = bintools.cb58Encode(tx.getNodeID());\n      const startTime = moment(tx.getStartTime().toNumber() * 1000)\n        .utc()\n        .format(format);\n\n      const endTime = moment(tx.getEndTime().toNumber() * 1000)\n        .utc()\n        .format(format);\n\n      const stakeAmt = bnToBig(tx.getStakeAmount(), 9);\n\n      const rewardOwners = tx.getRewardOwners();\n      const hrp = ava.getHRP();\n      const rewardAddrs = rewardOwners\n        .getOutput()\n        .getAddresses()\n        .map((addr) => {\n          return bintools.addressToString(hrp, chainId, addr);\n        });\n\n      messages.push({ title: \"NodeID\", value: nodeID });\n      messages.push({ title: \"Start Time\", value: startTime });\n      messages.push({ title: \"End Time\", value: endTime });\n      messages.push({ title: \"Total Stake\", value: `${stakeAmt} DJT` });\n      messages.push({\n        title: \"Stake\",\n        value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n      });\n      messages.push({\n        title: \"Reward to\",\n        value: `${rewardAddrs.join(\"\\n\")}`,\n      });\n      // @ts-ignore\n      if (tx.delegationFee) {\n        // @ts-ignore\n        messages.push({\n          title: \"Delegation Fee\",\n          //@ts-ignore\n          value: `${tx.delegationFee}%`,\n        });\n      }\n      messages.push({ title: \"Fee\", value: \"0\" });\n    }\n\n    return messages;\n  }\n\n  getFeeMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType): ILedgerBlockMessage[] {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const messages = [];\n\n    if (\n      (txType === AVMConstants.BASETX && chainId === \"V\") ||\n      (txType === AVMConstants.EXPORTTX && chainId === \"V\") ||\n      (txType === AVMConstants.IMPORTTX && chainId === \"V\") ||\n      (txType === PlatformVMConstants.EXPORTTX && chainId === \"M\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"M\") ||\n      (txType === EVMConstants.EXPORTTX && chainId === \"U\") ||\n      (txType === EVMConstants.IMPORTTX && chainId === \"U\")\n    ) {\n      messages.push({ title: \"Fee\", value: `${0.001} DJT` });\n    }\n\n    return messages;\n  }\n\n  // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n  getTransactionMessages<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType,\n    changePath: null | { toPathArray: () => number[] }\n  ): ILedgerBlockMessage[] {\n    const messages: ILedgerBlockMessage[] = [];\n\n    const outputMessages = this.getOutputMsgs(unsignedTx, chainId, changePath);\n    //@ts-ignore\n    messages.push(...outputMessages);\n\n    const validateDelegateMessages = this.getValidateDelegateMsgs(\n      unsignedTx as AVMUnsignedTx | PlatformUnsignedTx,\n      chainId\n    );\n    messages.push(...validateDelegateMessages);\n\n    const feeMessages = this.getFeeMsgs(unsignedTx, chainId);\n    messages.push(...feeMessages);\n\n    return messages;\n  }\n\n  getEvmTransactionMessages(tx: Transaction): ILedgerBlockMessage[] {\n    const gasPrice = tx.gasPrice;\n    const gasLimit = tx.gasLimit;\n    const totFee = gasPrice.mul(new BN(gasLimit));\n    const feeNano = bnToBig(totFee, 9);\n\n    let msgs: ILedgerBlockMessage[] = [];\n    try {\n      const test = \"0x\" + tx.data.toString(\"hex\");\n      const data = abiDecoder.decodeMethod(test);\n\n      const callMsg: ILedgerBlockMessage = {\n        title: \"Contract Call\",\n        value: data.name,\n      };\n      const paramMsgs: ILedgerBlockMessage[] = data.params.map((param: any) => {\n        return {\n          title: param.name,\n          value: param.value,\n        };\n      });\n\n      const feeMsg: ILedgerBlockMessage = {\n        title: \"Fee\",\n        value: feeNano.toLocaleString() + \" nDJTX\",\n      };\n\n      msgs = [callMsg, ...paramMsgs, feeMsg];\n    } catch (e) {\n      console.log(e);\n    }\n    return msgs;\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const chainId: ChainIdType = \"V\";\n\n    const parseableTxs = ParseableAvmTxEnum;\n    const { paths, isDjtxOnly } = this.getTransactionPaths<AVMUnsignedTx>(\n      unsignedTx,\n      chainId\n    );\n\n    // If ledger doesnt support parsing, sign hash\n    const canLedgerParse = this.config.version >= \"0.3.1\";\n    const isParsableType = txType in parseableTxs && isDjtxOnly;\n\n    let signedTx;\n    if (canLedgerParse && isParsableType) {\n      signedTx = await this.signTransactionParsable<AVMUnsignedTx, AVMTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    } else {\n      signedTx = await this.signTransactionHash<AVMUnsignedTx, AVMTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    }\n\n    store.commit(\"Ledger/closeModal\");\n    return signedTx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const chainId: ChainIdType = \"M\";\n    const parseableTxs = ParseablePlatformEnum;\n\n    const { paths, isDjtxOnly } = this.getTransactionPaths<PlatformUnsignedTx>(\n      unsignedTx,\n      chainId\n    );\n    // If ledger doesnt support parsing, sign hash\n    let canLedgerParse = this.config.version >= \"0.3.1\";\n    const isParsableType = txType in parseableTxs && isDjtxOnly;\n\n    // TODO: Remove after ledger is fixed\n    // If UTXOS contain lockedStakeable funds always use sign hash\n    const txIns = unsignedTx.getTransaction().getIns();\n    for (let i = 0; i < txIns.length; i++) {\n      const typeID = txIns[i].getInput().getTypeID();\n      if (typeID === PlatformVMConstants.STAKEABLELOCKINID) {\n        canLedgerParse = false;\n        break;\n      }\n    }\n\n    // TODO: Remove after ledger update\n    // Ledger is not able to parse P/C atomic transactions\n    if (txType === PlatformVMConstants.EXPORTTX) {\n      const destChainBuff = (tx as PlatformExportTx).getDestinationChain();\n      // If destination chain is C chain, sign hash\n      const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff));\n      if (destChain === \"U\") {\n        canLedgerParse = false;\n      }\n    }\n    // TODO: Remove after ledger update\n    if (txType === PlatformVMConstants.IMPORTTX) {\n      const sourceChainBuff = (tx as PlatformImportTx).getSourceChain();\n      // If destination chain is C chain, sign hash\n      const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff));\n      if (sourceChain === \"U\") {\n        canLedgerParse = false;\n      }\n    }\n\n    let signedTx;\n    if (canLedgerParse && isParsableType) {\n      signedTx = await this.signTransactionParsable<\n        PlatformUnsignedTx,\n        PlatformTx\n      >(unsignedTx, paths, chainId);\n    } else {\n      signedTx = await this.signTransactionHash<PlatformUnsignedTx, PlatformTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    }\n    store.commit(\"Ledger/closeModal\");\n    return signedTx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    // TODO: Might need to upgrade paths array to:\n    //  paths = Array(utxoSet.getAllUTXOs().length).fill('0/0'),\n    const tx = unsignedTx.getTransaction();\n    const typeId = tx.getTxType();\n\n    let canLedgerParse = true;\n\n    let paths = [\"0/0\"];\n    if (typeId === EVMConstants.EXPORTTX) {\n      const ins = (tx as EVMExportTx).getInputs();\n      paths = ins.map((input) => \"0/0\");\n    } else if (typeId === EVMConstants.IMPORTTX) {\n      const ins = (tx as EVMImportTx).getImportInputs();\n      paths = ins.map((input) => \"0/0\");\n    }\n\n    // TODO: Remove after ledger update\n    // Ledger is not able to parse P/C atomic transactions\n    if (typeId === EVMConstants.EXPORTTX) {\n      const destChainBuff = (tx as EVMExportTx).getDestinationChain();\n      // If destination chain is C chain, sign hash\n      const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff));\n      if (destChain === \"M\") {\n        canLedgerParse = false;\n      }\n    }\n    // TODO: Remove after ledger update\n    if (typeId === EVMConstants.IMPORTTX) {\n      const sourceChainBuff = (tx as EVMImportTx).getSourceChain();\n      // If destination chain is C chain, sign hash\n      const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff));\n      if (sourceChain === \"M\") {\n        canLedgerParse = false;\n      }\n    }\n\n    let txSigned;\n    if (canLedgerParse) {\n      txSigned = (await this.signTransactionParsable(\n        unsignedTx,\n        paths,\n        \"U\"\n      )) as EvmTx;\n    } else {\n      txSigned = (await this.signTransactionHash(\n        unsignedTx,\n        paths,\n        \"U\"\n      )) as EvmTx;\n    }\n    store.commit(\"Ledger/closeModal\");\n    return txSigned;\n  }\n\n  async signEvm(tx: Transaction) {\n    const rawUnsignedTx = rlp.encode([\n      bnToRlp(tx.nonce),\n      bnToRlp(tx.gasPrice),\n      bnToRlp(tx.gasLimit),\n      tx.to !== undefined ? tx.to.buf : Buffer.from([]),\n      bnToRlp(tx.value),\n      tx.data,\n      bnToRlp(new BN(tx.getChainId())),\n      Buffer.from([]),\n      Buffer.from([]),\n    ]);\n\n    try {\n      const msgs = this.getEvmTransactionMessages(tx);\n\n      // Open Modal Prompt\n      store.commit(\"Ledger/openModal\", {\n        title: \"Transfer\",\n        messages: msgs,\n        info: null,\n      });\n      const signature = await this.ethApp.signTransaction(\n        LEDGER_ETH_ACCOUNT_PATH,\n        rawUnsignedTx.toString(\"hex\")\n      );\n      store.commit(\"Ledger/closeModal\");\n\n      const signatureBN = {\n        v: new BN(signature.v, 16),\n        r: new BN(signature.r, 16),\n        s: new BN(signature.s, 16),\n      };\n\n      const chainId = await web3.eth.getChainId();\n      const networkId = await web3.eth.net.getId();\n      const chainParams = {\n        common: EthereumjsCommon.forCustomChain(\n          \"mainnet\",\n          { networkId, chainId },\n          \"istanbul\"\n        ),\n      };\n\n      const signedTx = Transaction.fromTxData(\n        {\n          nonce: tx.nonce,\n          gasPrice: tx.gasPrice,\n          gasLimit: tx.gasLimit,\n          to: tx.to,\n          value: tx.value,\n          data: tx.data,\n          ...signatureBN,\n        },\n        chainParams\n      );\n      return signedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async getUTXOs(): Promise<void> {\n    // TODO: Move to shared file\n    this.isFetchUtxos = true;\n    // If we are waiting for helpers to initialize delay the call\n    const isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n    if (!isInit) {\n      setTimeout(() => {\n        this.getUTXOs();\n      }, 1000);\n      return;\n    }\n\n    super.getUTXOs();\n    this.getStake();\n    this.getEthBalance();\n    return;\n  }\n\n  getPathFromAddress(address: string) {\n    const externalAddrs = this.externalHelper.getExtendedAddresses();\n    const internalAddrs = this.internalHelper.getExtendedAddresses();\n    const platformAddrs = this.platformHelper.getExtendedAddresses();\n\n    const extIndex = externalAddrs.indexOf(address);\n    const intIndex = internalAddrs.indexOf(address);\n    const platformIndex = platformAddrs.indexOf(address);\n\n    if (extIndex >= 0) {\n      return `0/${extIndex}`;\n    } else if (intIndex >= 0) {\n      return `1/${intIndex}`;\n    } else if (platformIndex >= 0) {\n      return `0/${platformIndex}`;\n    } else if (address[0] === \"U\") {\n      return \"0/0\";\n    } else {\n      throw \"Unable to find source address.\";\n    }\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: Buffer | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async signHashByExternalIndex(index: number, hash: Buffer) {\n    const pathStr = `0/${index}`;\n    const addressPath = bippath.fromString(pathStr, false);\n    const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`);\n\n    store.commit(\"Ledger/openModal\", {\n      title: `Sign Hash`,\n      info: hash.toString(\"hex\").toUpperCase(),\n    });\n\n    try {\n      const sigMap = await this.app.signHash(accountPath, [addressPath], hash);\n      store.commit(\"Ledger/closeModal\");\n      const signed = sigMap.get(pathStr);\n      return bintools.cb58Encode(signed);\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      throw e;\n    }\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    // throw 'Not Implemented'\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n}\n\nexport { LedgerWallet };\n","var isoLangs = {\n  ab: {\n    name: \"Abkhaz\",\n    nativeName: \"аҧсуа\",\n  },\n  aa: {\n    name: \"Afar\",\n    nativeName: \"Afaraf\",\n  },\n  af: {\n    name: \"Afrikaans\",\n    nativeName: \"Afrikaans\",\n  },\n  ak: {\n    name: \"Akan\",\n    nativeName: \"Akan\",\n  },\n  sq: {\n    name: \"Albanian\",\n    nativeName: \"Shqip\",\n  },\n  am: {\n    name: \"Amharic\",\n    nativeName: \"አማርኛ\",\n  },\n  ar: {\n    name: \"Arabic\",\n    nativeName: \"العربية\",\n  },\n  an: {\n    name: \"Aragonese\",\n    nativeName: \"Aragonés\",\n  },\n  hy: {\n    name: \"Armenian\",\n    nativeName: \"Հայերեն\",\n  },\n  as: {\n    name: \"Assamese\",\n    nativeName: \"অসমীয়া\",\n  },\n  av: {\n    name: \"Avaric\",\n    nativeName: \"авар мацӀ, магӀарул мацӀ\",\n  },\n  ae: {\n    name: \"Avestan\",\n    nativeName: \"avesta\",\n  },\n  ay: {\n    name: \"Aymara\",\n    nativeName: \"aymar aru\",\n  },\n  az: {\n    name: \"Azerbaijani\",\n    nativeName: \"azərbaycan dili\",\n  },\n  bm: {\n    name: \"Bambara\",\n    nativeName: \"bamanankan\",\n  },\n  ba: {\n    name: \"Bashkir\",\n    nativeName: \"башҡорт теле\",\n  },\n  eu: {\n    name: \"Basque\",\n    nativeName: \"euskara, euskera\",\n  },\n  be: {\n    name: \"Belarusian\",\n    nativeName: \"Беларуская\",\n  },\n  bn: {\n    name: \"Bengali\",\n    nativeName: \"বাংলা\",\n  },\n  bh: {\n    name: \"Bihari\",\n    nativeName: \"भोजपुरी\",\n  },\n  bi: {\n    name: \"Bislama\",\n    nativeName: \"Bislama\",\n  },\n  bs: {\n    name: \"Bosnian\",\n    nativeName: \"bosanski jezik\",\n  },\n  br: {\n    name: \"Breton\",\n    nativeName: \"brezhoneg\",\n  },\n  bg: {\n    name: \"Bulgarian\",\n    nativeName: \"български език\",\n  },\n  my: {\n    name: \"Burmese\",\n    nativeName: \"ဗမာစာ\",\n  },\n  ca: {\n    name: \"Catalan; Valencian\",\n    nativeName: \"Català\",\n  },\n  ch: {\n    name: \"Chamorro\",\n    nativeName: \"Chamoru\",\n  },\n  ce: {\n    name: \"Chechen\",\n    nativeName: \"нохчийн мотт\",\n  },\n  ny: {\n    name: \"Chichewa; Chewa; Nyanja\",\n    nativeName: \"chiCheŵa, chinyanja\",\n  },\n  cn: {\n    name: \"Chinese\",\n    nativeName: \"中文 (Zhōngwén), 汉语, 漢語\",\n  },\n  zh_hans: {\n    name: \"Chinese (Simplified)\",\n    nativeName: \"汉语\",\n  },\n  zh_hant: {\n    name: \"Chinese (Traditional)\",\n    nativeName: \"漢語\",\n  },\n  cv: {\n    name: \"Chuvash\",\n    nativeName: \"чӑваш чӗлхи\",\n  },\n  kw: {\n    name: \"Cornish\",\n    nativeName: \"Kernewek\",\n  },\n  co: {\n    name: \"Corsican\",\n    nativeName: \"corsu, lingua corsa\",\n  },\n  cr: {\n    name: \"Cree\",\n    nativeName: \"ᓀᐦᐃᔭᐍᐏᐣ\",\n  },\n  hr: {\n    name: \"Croatian\",\n    nativeName: \"hrvatski\",\n  },\n  cs: {\n    name: \"Czech\",\n    nativeName: \"česky, čeština\",\n  },\n  da: {\n    name: \"Danish\",\n    nativeName: \"dansk\",\n  },\n  dv: {\n    name: \"Divehi; Dhivehi; Maldivian;\",\n    nativeName: \"ދިވެހި\",\n  },\n  nl: {\n    name: \"Dutch\",\n    nativeName: \"Nederlands, Vlaams\",\n  },\n  en: {\n    name: \"EN\",\n    nativeName: \"EN\",\n  },\n  eo: {\n    name: \"Esperanto\",\n    nativeName: \"Esperanto\",\n  },\n  et: {\n    name: \"Estonian\",\n    nativeName: \"eesti, eesti keel\",\n  },\n  ee: {\n    name: \"Ewe\",\n    nativeName: \"Eʋegbe\",\n  },\n  fo: {\n    name: \"Faroese\",\n    nativeName: \"føroyskt\",\n  },\n  fj: {\n    name: \"Fijian\",\n    nativeName: \"vosa Vakaviti\",\n  },\n  fi: {\n    name: \"Finnish\",\n    nativeName: \"suomi, suomen kieli\",\n  },\n  fr: {\n    name: \"French\",\n    nativeName: \"Français\",\n  },\n  ff: {\n    name: \"Fula; Fulah; Pulaar; Pular\",\n    nativeName: \"Fulfulde, Pulaar, Pular\",\n  },\n  gl: {\n    name: \"Galician\",\n    nativeName: \"Galego\",\n  },\n  ka: {\n    name: \"Georgian\",\n    nativeName: \"ქართული\",\n  },\n  de: {\n    name: \"German\",\n    nativeName: \"Deutsch\",\n  },\n  el: {\n    name: \"Greek, Modern\",\n    nativeName: \"Ελληνικά\",\n  },\n  gn: {\n    name: \"Guaraní\",\n    nativeName: \"Avañeẽ\",\n  },\n  gu: {\n    name: \"Gujarati\",\n    nativeName: \"ગુજરાતી\",\n  },\n  ht: {\n    name: \"Haitian; Haitian Creole\",\n    nativeName: \"Kreyòl ayisyen\",\n  },\n  ha: {\n    name: \"Hausa\",\n    nativeName: \"Hausa, هَوُسَ\",\n  },\n  he: {\n    name: \"Hebrew (modern)\",\n    nativeName: \"עברית\",\n  },\n  hz: {\n    name: \"Herero\",\n    nativeName: \"Otjiherero\",\n  },\n  hi: {\n    name: \"Hindi\",\n    nativeName: \"हिन्दी, हिंदी\",\n  },\n  ho: {\n    name: \"Hiri Motu\",\n    nativeName: \"Hiri Motu\",\n  },\n  hu: {\n    name: \"Hungarian\",\n    nativeName: \"Magyar\",\n  },\n  ia: {\n    name: \"Interlingua\",\n    nativeName: \"Interlingua\",\n  },\n  id: {\n    name: \"Indonesian\",\n    nativeName: \"Bahasa Indonesia\",\n  },\n  ie: {\n    name: \"Interlingue\",\n    nativeName: \"Originally called Occidental; then Interlingue after WWII\",\n  },\n  ga: {\n    name: \"Irish\",\n    nativeName: \"Gaeilge\",\n  },\n  ig: {\n    name: \"Igbo\",\n    nativeName: \"Asụsụ Igbo\",\n  },\n  ik: {\n    name: \"Inupiaq\",\n    nativeName: \"Iñupiaq, Iñupiatun\",\n  },\n  io: {\n    name: \"Ido\",\n    nativeName: \"Ido\",\n  },\n  is: {\n    name: \"Icelandic\",\n    nativeName: \"Íslenska\",\n  },\n  it: {\n    name: \"Italian\",\n    nativeName: \"Italiano\",\n  },\n  iu: {\n    name: \"Inuktitut\",\n    nativeName: \"ᐃᓄᒃᑎᑐᑦ\",\n  },\n  ja: {\n    name: \"Japanese\",\n    nativeName: \"日本語\",\n  },\n  jv: {\n    name: \"Javanese\",\n    nativeName: \"basa Jawa\",\n  },\n  kl: {\n    name: \"Kalaallisut, Greenlandic\",\n    nativeName: \"kalaallisut, kalaallit oqaasii\",\n  },\n  kn: {\n    name: \"Kannada\",\n    nativeName: \"ಕನ್ನಡ\",\n  },\n  // \"kr\": {\n  //     \"name\": \"Kanuri\",\n  //     \"nativeName\": \"Kanuri\"\n  // },\n  ks: {\n    name: \"Kashmiri\",\n    nativeName: \"कश्मीरी, كشميري‎\",\n  },\n  kk: {\n    name: \"Kazakh\",\n    nativeName: \"Қазақ тілі\",\n  },\n  km: {\n    name: \"Khmer\",\n    nativeName: \"ភាសាខ្មែរ\",\n  },\n  ki: {\n    name: \"Kikuyu, Gikuyu\",\n    nativeName: \"Gĩkũyũ\",\n  },\n  rw: {\n    name: \"Kinyarwanda\",\n    nativeName: \"Ikinyarwanda\",\n  },\n  ky: {\n    name: \"Kirghiz, Kyrgyz\",\n    nativeName: \"кыргыз тили\",\n  },\n  kv: {\n    name: \"Komi\",\n    nativeName: \"коми кыв\",\n  },\n  kg: {\n    name: \"Kongo\",\n    nativeName: \"KiKongo\",\n  },\n  kr: {\n    name: \"Korean\",\n    nativeName: \"한국어\",\n  },\n  ku: {\n    name: \"Kurdish\",\n    nativeName: \"Kurdî, كوردی‎\",\n  },\n  kj: {\n    name: \"Kwanyama, Kuanyama\",\n    nativeName: \"Kuanyama\",\n  },\n  la: {\n    name: \"Latin\",\n    nativeName: \"latine, lingua latina\",\n  },\n  lb: {\n    name: \"Luxembourgish, Letzeburgesch\",\n    nativeName: \"Lëtzebuergesch\",\n  },\n  lg: {\n    name: \"Luganda\",\n    nativeName: \"Luganda\",\n  },\n  li: {\n    name: \"Limburgish, Limburgan, Limburger\",\n    nativeName: \"Limburgs\",\n  },\n  ln: {\n    name: \"Lingala\",\n    nativeName: \"Lingála\",\n  },\n  lo: {\n    name: \"Lao\",\n    nativeName: \"ພາສາລາວ\",\n  },\n  lt: {\n    name: \"Lithuanian\",\n    nativeName: \"lietuvių kalba\",\n  },\n  lu: {\n    name: \"Luba-Katanga\",\n    nativeName: \"\",\n  },\n  lv: {\n    name: \"Latvian\",\n    nativeName: \"latviešu valoda\",\n  },\n  gv: {\n    name: \"Manx\",\n    nativeName: \"Gaelg, Gailck\",\n  },\n  mk: {\n    name: \"Macedonian\",\n    nativeName: \"македонски јазик\",\n  },\n  mg: {\n    name: \"Malagasy\",\n    nativeName: \"Malagasy fiteny\",\n  },\n  ms: {\n    name: \"Malay\",\n    nativeName: \"bahasa Melayu, بهاس ملايو‎\",\n  },\n  ml: {\n    name: \"Malayalam\",\n    nativeName: \"മലയാളം\",\n  },\n  mt: {\n    name: \"Maltese\",\n    nativeName: \"Malti\",\n  },\n  mi: {\n    name: \"Māori\",\n    nativeName: \"te reo Māori\",\n  },\n  mr: {\n    name: \"Marathi (Marāṭhī)\",\n    nativeName: \"मराठी\",\n  },\n  mh: {\n    name: \"Marshallese\",\n    nativeName: \"Kajin M̧ajeļ\",\n  },\n  mn: {\n    name: \"Mongolian\",\n    nativeName: \"монгол\",\n  },\n  na: {\n    name: \"Nauru\",\n    nativeName: \"Ekakairũ Naoero\",\n  },\n  nv: {\n    name: \"Navajo, Navaho\",\n    nativeName: \"Diné bizaad, Dinékʼehǰí\",\n  },\n  nb: {\n    name: \"Norwegian Bokmål\",\n    nativeName: \"Norsk bokmål\",\n  },\n  nd: {\n    name: \"North Ndebele\",\n    nativeName: \"isiNdebele\",\n  },\n  ne: {\n    name: \"Nepali\",\n    nativeName: \"नेपाली\",\n  },\n  ng: {\n    name: \"Ndonga\",\n    nativeName: \"Owambo\",\n  },\n  nn: {\n    name: \"Norwegian Nynorsk\",\n    nativeName: \"Norsk nynorsk\",\n  },\n  no: {\n    name: \"Norwegian\",\n    nativeName: \"Norsk\",\n  },\n  ii: {\n    name: \"Nuosu\",\n    nativeName: \"ꆈꌠ꒿ Nuosuhxop\",\n  },\n  nr: {\n    name: \"South Ndebele\",\n    nativeName: \"isiNdebele\",\n  },\n  oc: {\n    name: \"Occitan\",\n    nativeName: \"Occitan\",\n  },\n  oj: {\n    name: \"Ojibwe, Ojibwa\",\n    nativeName: \"ᐊᓂᔑᓈᐯᒧᐎᓐ\",\n  },\n  cu: {\n    name:\n      \"Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic\",\n    nativeName: \"ѩзыкъ словѣньскъ\",\n  },\n  om: {\n    name: \"Oromo\",\n    nativeName: \"Afaan Oromoo\",\n  },\n  or: {\n    name: \"Oriya\",\n    nativeName: \"ଓଡ଼ିଆ\",\n  },\n  os: {\n    name: \"Ossetian, Ossetic\",\n    nativeName: \"ирон æвзаг\",\n  },\n  pa: {\n    name: \"Panjabi, Punjabi\",\n    nativeName: \"ਪੰਜਾਬੀ, پنجابی‎\",\n  },\n  pi: {\n    name: \"Pāli\",\n    nativeName: \"पाऴि\",\n  },\n  fa: {\n    name: \"Persian\",\n    nativeName: \"فارسی\",\n  },\n  pl: {\n    name: \"Polish\",\n    nativeName: \"polski\",\n  },\n  ps: {\n    name: \"Pashto, Pushto\",\n    nativeName: \"پښتو\",\n  },\n  pt: {\n    name: \"Portuguese\",\n    nativeName: \"Português\",\n  },\n  qu: {\n    name: \"Quechua\",\n    nativeName: \"Runa Simi, Kichwa\",\n  },\n  rm: {\n    name: \"Romansh\",\n    nativeName: \"rumantsch grischun\",\n  },\n  rn: {\n    name: \"Kirundi\",\n    nativeName: \"kiRundi\",\n  },\n  ro: {\n    name: \"Romanian, Moldavian, Moldovan\",\n    nativeName: \"română\",\n  },\n  ru: {\n    name: \"Russian\",\n    nativeName: \"русский язык\",\n  },\n  sa: {\n    name: \"Sanskrit (Saṁskṛta)\",\n    nativeName: \"संस्कृतम्\",\n  },\n  sc: {\n    name: \"Sardinian\",\n    nativeName: \"sardu\",\n  },\n  sd: {\n    name: \"Sindhi\",\n    nativeName: \"सिन्धी, سنڌي، سندھی‎\",\n  },\n  se: {\n    name: \"Northern Sami\",\n    nativeName: \"Davvisámegiella\",\n  },\n  sm: {\n    name: \"Samoan\",\n    nativeName: \"gagana faa Samoa\",\n  },\n  sg: {\n    name: \"Sango\",\n    nativeName: \"yângâ tî sängö\",\n  },\n  sr: {\n    name: \"Serbian\",\n    nativeName: \"српски језик\",\n  },\n  gd: {\n    name: \"Scottish Gaelic; Gaelic\",\n    nativeName: \"Gàidhlig\",\n  },\n  sn: {\n    name: \"Shona\",\n    nativeName: \"chiShona\",\n  },\n  si: {\n    name: \"Sinhala, Sinhalese\",\n    nativeName: \"සිංහල\",\n  },\n  sk: {\n    name: \"Slovak\",\n    nativeName: \"slovenčina\",\n  },\n  sl: {\n    name: \"Slovene\",\n    nativeName: \"slovenščina\",\n  },\n  so: {\n    name: \"Somali\",\n    nativeName: \"Soomaaliga, af Soomaali\",\n  },\n  st: {\n    name: \"Southern Sotho\",\n    nativeName: \"Sesotho\",\n  },\n  es: {\n    name: \"Spanish; Castilian\",\n    nativeName: \"Español\",\n  },\n  su: {\n    name: \"Sundanese\",\n    nativeName: \"Basa Sunda\",\n  },\n  sw: {\n    name: \"Swahili\",\n    nativeName: \"Kiswahili\",\n  },\n  ss: {\n    name: \"Swati\",\n    nativeName: \"SiSwati\",\n  },\n  sv: {\n    name: \"Swedish\",\n    nativeName: \"svenska\",\n  },\n  ta: {\n    name: \"Tamil\",\n    nativeName: \"தமிழ்\",\n  },\n  te: {\n    name: \"Telugu\",\n    nativeName: \"తెలుగు\",\n  },\n  tg: {\n    name: \"Tajik\",\n    nativeName: \"тоҷикӣ, toğikī, تاجیکی‎\",\n  },\n  th: {\n    name: \"Thai\",\n    nativeName: \"ไทย\",\n  },\n  ti: {\n    name: \"Tigrinya\",\n    nativeName: \"ትግርኛ\",\n  },\n  bo: {\n    name: \"Tibetan Standard, Tibetan, Central\",\n    nativeName: \"བོད་ཡིག\",\n  },\n  tk: {\n    name: \"Turkmen\",\n    nativeName: \"Türkmen, Түркмен\",\n  },\n  tl: {\n    name: \"Tagalog\",\n    nativeName: \"Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔\",\n  },\n  tn: {\n    name: \"Tswana\",\n    nativeName: \"Setswana\",\n  },\n  to: {\n    name: \"Tonga (Tonga Islands)\",\n    nativeName: \"faka Tonga\",\n  },\n  tr: {\n    name: \"Turkish\",\n    nativeName: \"Türkçe\",\n  },\n  ts: {\n    name: \"Tsonga\",\n    nativeName: \"Xitsonga\",\n  },\n  tt: {\n    name: \"Tatar\",\n    nativeName: \"татарча, tatarça, تاتارچا‎\",\n  },\n  tw: {\n    name: \"Twi\",\n    nativeName: \"Twi\",\n  },\n  ty: {\n    name: \"Tahitian\",\n    nativeName: \"Reo Tahiti\",\n  },\n  ug: {\n    name: \"Uighur, Uyghur\",\n    nativeName: \"Uyƣurqə, ئۇيغۇرچە‎\",\n  },\n  uk: {\n    name: \"Ukrainian\",\n    nativeName: \"українська\",\n  },\n  ur: {\n    name: \"Urdu\",\n    nativeName: \"اردو\",\n  },\n  uz: {\n    name: \"Uzbek\",\n    nativeName: \"zbek, Ўзбек, أۇزبېك‎\",\n  },\n  ve: {\n    name: \"Venda\",\n    nativeName: \"Tshivenḓa\",\n  },\n  vn: {\n    name: \"Vietnamese\",\n    nativeName: \"Tiếng Việt\",\n  },\n  vo: {\n    name: \"Volapük\",\n    nativeName: \"Volapük\",\n  },\n  wa: {\n    name: \"Walloon\",\n    nativeName: \"Walon\",\n  },\n  cy: {\n    name: \"Welsh\",\n    nativeName: \"Cymraeg\",\n  },\n  wo: {\n    name: \"Wolof\",\n    nativeName: \"Wollof\",\n  },\n  fy: {\n    name: \"Western Frisian\",\n    nativeName: \"Frysk\",\n  },\n  xh: {\n    name: \"Xhosa\",\n    nativeName: \"isiXhosa\",\n  },\n  yi: {\n    name: \"Yiddish\",\n    nativeName: \"ייִדיש\",\n  },\n  yo: {\n    name: \"Yoruba\",\n    nativeName: \"Yorùbá\",\n  },\n  za: {\n    name: \"Zhuang, Chuang\",\n    nativeName: \"Saɯ cueŋƅ, Saw cuengh\",\n  },\n};\n\nexport default isoLangs;\n","import CryptoJS from \"crypto-js/core\";\nimport AES from \"crypto-js/aes\";\nconst randomstring = require(\"randomstring\");\nimport * as bip39 from \"bip39\";\n\n// The purpose of this class is for obfuscation only rather than secure encryption\nexport default class MnemonicPhrase {\n  private pass: string;\n  private encrypted: any;\n\n  constructor(mnemonic: string) {\n    if (!bip39.validateMnemonic(mnemonic))\n      throw new Error(\"Invalid mnemonic phrase.\");\n    this.pass = randomstring.generate(32);\n    this.encrypted = AES.encrypt(mnemonic, this.pass).toString();\n  }\n\n  public getValue() {\n    const decrypted = AES.decrypt(this.encrypted, this.pass).toString(\n      CryptoJS.enc.Utf8\n    );\n    if (!bip39.validateMnemonic(decrypted))\n      throw new Error(\"Decrypted mnemonic is not valid.\");\n    return decrypted;\n  }\n}\n","import { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { digestMessage } from \"@/helpers/helper\";\nimport { WalletNameType } from \"@/js/wallets/types\";\n\nimport { Buffer as BufferAvalanche, BN } from \"avalanche\";\nimport {\n  KeyPair as AVMKeyPair,\n  KeyChain as AVMKeyChain,\n  UTXOSet as AVMUTXOSet,\n  UTXO,\n  UnsignedTx,\n} from \"avalanche/dist/apis/avm\";\nimport {\n  KeyPair as PlatformKeyPair,\n  KeyChain as PlatformKeyChain,\n  UTXOSet as PlatformUTXOSet,\n  UTXOSet,\n} from \"avalanche/dist/apis/platformvm\";\nimport {\n  KeyChain,\n  KeyChain as EVMKeyChain,\n  UTXOSet as EVMUTXOSet,\n} from \"avalanche/dist/apis/evm\";\nimport { PayloadBase } from \"avalanche/dist/utils\";\nimport { buildUnsignedTransaction } from \"../TxHelper\";\nimport { AvaWalletCore, UnsafeWallet } from \"./types\";\nimport { UTXO as PlatformUTXO } from \"avalanche/dist/apis/platformvm/utxos\";\nimport { privateToAddress } from \"ethereumjs-util\";\nimport {\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n} from \"avalanche/dist/apis/avm/tx\";\nimport {\n  Tx as PlatformTx,\n  UnsignedTx as PlatformUnsignedTx,\n} from \"avalanche/dist/apis/platformvm/tx\";\nimport {\n  Tx as EvmTx,\n  UnsignedTx as EVMUnsignedTx,\n} from \"avalanche/dist/apis/evm/tx\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletCore } from \"@/js/wallets/WalletCore\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from \"@/helpers/utxo_helper\";\nimport { UTXO as AVMUTXO } from \"avalanche/dist/apis/avm/utxos\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport {\n  ExportChainsC,\n  ExportChainsP,\n  ExportChainsX,\n} from \"@avalabs/avalanche-wallet-sdk\";\n\nclass SingletonWallet\n  extends WalletCore\n  implements AvaWalletCore, UnsafeWallet {\n  keyChain: AVMKeyChain;\n  keyPair: AVMKeyPair;\n\n  platformKeyChain: PlatformKeyChain;\n  platformKeyPair: PlatformKeyPair;\n\n  chainId: string;\n  chainIdP: string;\n\n  key: string;\n\n  stakeAmount: BN;\n\n  type: WalletNameType;\n\n  ethKey: string;\n  ethKeyBech: string;\n  ethKeyChain: EVMKeyChain;\n  ethAddress: string;\n  ethAddressBech: string;\n  ethBalance: BN;\n\n  constructor(pk: string) {\n    super();\n\n    this.key = pk;\n\n    this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID();\n    this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID();\n\n    const hrp = ava.getHRP();\n\n    this.keyChain = new AVMKeyChain(hrp, this.chainId);\n    this.keyPair = this.keyChain.importKey(pk);\n\n    this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP);\n    this.platformKeyPair = this.platformKeyChain.importKey(pk);\n\n    this.stakeAmount = new BN(0);\n\n    // Derive EVM key and address\n    const pkBuf = bintools.cb58Decode(pk.split(\"-\")[1]);\n    const pkHex = pkBuf.toString(\"hex\");\n    const pkBuffNative = Buffer.from(pkHex, \"hex\");\n\n    this.ethKey = pkHex;\n    this.ethAddress = privateToAddress(pkBuffNative).toString(\"hex\");\n    this.ethBalance = new BN(0);\n\n    const cPrivKey =\n      `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(pkBuf));\n    this.ethKeyBech = cPrivKey;\n    const cKeyChain = new KeyChain(ava.getHRP(), \"U\");\n    this.ethKeyChain = cKeyChain;\n\n    const cKeypair = cKeyChain.importKey(cPrivKey);\n    this.ethAddressBech = cKeypair.getAddressString();\n\n    this.type = \"singleton\";\n    this.isInit = true;\n  }\n\n  getChangeAddressAvm(): string {\n    return this.getCurrentAddressAvm();\n  }\n\n  getCurrentAddressAvm(): string {\n    return this.keyPair.getAddressString();\n  }\n\n  getChangeAddressPlatform(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  getDerivedAddresses(): string[] {\n    const addr = this.getCurrentAddressAvm();\n    return [addr];\n  }\n\n  getDerivedAddressesP() {\n    return [this.getCurrentAddressPlatform()];\n  }\n\n  getAllDerivedExternalAddresses(): string[] {\n    return this.getDerivedAddresses();\n  }\n\n  getExtendedPlatformAddresses(): string[] {\n    const addr = this.platformKeyPair.getAddressString();\n    return [addr];\n  }\n\n  getHistoryAddresses(): string[] {\n    const addr = this.getCurrentAddressAvm();\n    return [addr];\n  }\n\n  getPlatformRewardAddress(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  getCurrentAddressPlatform(): string {\n    return this.platformKeyPair.getAddressString();\n  }\n\n  getBaseAddress(): string {\n    return this.getCurrentAddressAvm();\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  getPlatformUTXOSet(): PlatformUTXOSet {\n    return this.platformUtxoset;\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  getEvmAddressBech(): string {\n    return this.ethAddressBech;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async updateUTXOsX(): Promise<AVMUTXOSet> {\n    const result = await avmGetAllUTXOs([this.getCurrentAddressAvm()]);\n    this.utxoset = result;\n    return result;\n  }\n\n  async updateUTXOsP(): Promise<PlatformUTXOSet> {\n    const result = await platformGetAllUTXOs([\n      this.getCurrentAddressPlatform(),\n    ]);\n    this.platformUtxoset = result;\n    return result;\n  }\n\n  async getUTXOs(): Promise<void> {\n    this.isFetchUtxos = true;\n\n    await this.updateUTXOsX();\n    await this.updateUTXOsP();\n\n    await this.getStake();\n    await this.getEthBalance();\n\n    this.isFetchUtxos = false;\n\n    return;\n  }\n\n  async buildUnsignedTransaction(\n    orders: (ITransaction | UTXO)[],\n    addr: string,\n    memo?: BufferAvalanche\n  ) {\n    const changeAddress = this.getChangeAddressAvm();\n    const derivedAddresses = this.getDerivedAddresses();\n    const utxoset = this.getUTXOSet() as AVMUTXOSet;\n\n    return buildUnsignedTransaction(\n      orders,\n      addr,\n      derivedAddresses,\n      utxoset,\n      changeAddress,\n      memo\n    );\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: BufferAvalanche | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  getFirstAvailableAddressPlatform(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  onnetworkchange(): void {\n    const hrp = ava.getHRP();\n\n    this.keyChain = new AVMKeyChain(hrp, this.chainId);\n    this.utxoset = new AVMUTXOSet();\n    this.keyPair = this.keyChain.importKey(this.key);\n\n    this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP);\n    this.platformUtxoset = new PlatformUTXOSet();\n    this.platformKeyPair = this.platformKeyChain.importKey(this.key);\n\n    // Update EVM values\n    this.ethKeyChain = new EVMKeyChain(ava.getHRP(), \"U\");\n    const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech);\n    this.ethAddressBech = cKeypair.getAddressString();\n    this.ethBalance = new BN(0);\n\n    this.getUTXOs();\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const keychain = this.keyChain;\n\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const keychain = this.platformKeyChain;\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    const keyChain = this.ethKeyChain;\n    return unsignedTx.sign(keyChain);\n  }\n\n  async signEvm(tx: Transaction) {\n    const keyBuff = Buffer.from(this.ethKey, \"hex\");\n    return tx.sign(keyBuff);\n  }\n\n  async signMessage(msgStr: string): Promise<string> {\n    const digest = digestMessage(msgStr);\n\n    const digestHex = digest.toString(\"hex\");\n    const digestBuff = BufferAvalanche.from(digestHex, \"hex\");\n    const signed = this.keyPair.sign(digestBuff);\n\n    return bintools.cb58Encode(signed);\n  }\n\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number = 0,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n\n  getAllAddressesX() {\n    return [this.getCurrentAddressAvm()];\n  }\n\n  getAllAddressesP() {\n    return [this.getCurrentAddressPlatform()];\n  }\n}\n\nexport { SingletonWallet };\n","class AvaNftFamily {\n  id: string;\n  name: string;\n  symbol: string;\n\n  constructor(id: string, name: string, symbol: string) {\n    this.id = id;\n    this.name = name;\n    this.symbol = symbol;\n  }\n}\n\nexport { AvaNftFamily };\n","/*\nThe base wallet class used for common functionality\n*/\nimport { BN } from \"avalanche\";\nimport { UTXOSet as AVMUTXOSet } from \"avalanche/dist/apis/avm\";\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm\";\nimport {\n  ExportChainsC,\n  ExportChainsP,\n  ExportChainsX,\n  UtxoHelper,\n  TxHelper,\n  GasHelper,\n  chainIdFromAlias,\n  xChain,\n} from \"@avalabs/avalanche-wallet-sdk\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { UTXOSet as EVMUTXOSet } from \"avalanche/dist/apis/evm/utxos\";\nimport {\n  Tx as EVMTx,\n  UnsignedTx as EVMUnsignedTx,\n} from \"avalanche/dist/apis/evm/tx\";\nimport {\n  Tx as PlatformTx,\n  UnsignedTx as PlatformUnsignedTx,\n} from \"avalanche/dist/apis/platformvm/tx\";\nimport {\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n} from \"avalanche/dist/apis/avm/tx\";\nimport { AvmImportChainType, WalletType } from \"@/js/wallets/types\";\nimport { issueC, issueP, issueX } from \"@/helpers/issueTx\";\nconst uniqid = require(\"uniqid\");\n\nabstract class WalletCore {\n  id: string;\n\n  utxoset: AVMUTXOSet;\n  platformUtxoset: PlatformUTXOSet;\n  stakeAmount: BN;\n\n  isFetchUtxos: boolean;\n  isInit: boolean;\n\n  abstract getEvmAddressBech(): string;\n  abstract getEvmAddress(): string;\n  abstract getCurrentAddressAvm(): string;\n  abstract getChangeAddressAvm(): string;\n  abstract getCurrentAddressPlatform(): string;\n  abstract getAllAddressesP(): string[];\n  abstract getAllAddressesX(): string[];\n\n  abstract async signC(unsignedTx: EVMUnsignedTx): Promise<EVMTx>;\n  abstract async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx>;\n  abstract async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx>;\n\n  abstract async signMessage(msg: string, address?: string): Promise<string>;\n  abstract getPlatformUTXOSet(): PlatformUTXOSet;\n\n  getUTXOSet(): AVMUTXOSet {\n    return this.utxoset;\n  }\n\n  protected constructor() {\n    this.id = uniqid();\n    this.utxoset = new AVMUTXOSet();\n    this.platformUtxoset = new PlatformUTXOSet();\n    this.stakeAmount = new BN(0);\n\n    this.isInit = false;\n    this.isFetchUtxos = false;\n  }\n\n  async evmGetAtomicUTXOs(sourceChain: ExportChainsC) {\n    const addrs = [this.getEvmAddressBech()];\n    return await UtxoHelper.evmGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async createImportTxC(\n    sourceChain: ExportChainsC,\n    utxoSet: EVMUTXOSet,\n    fee: BN\n  ) {\n    const bechAddr = this.getEvmAddressBech();\n    const hexAddr = this.getEvmAddress();\n\n    const toAddress = \"0x\" + hexAddr;\n    const ownerAddresses = [bechAddr];\n    const fromAddresses = ownerAddresses;\n    const sourceChainId = chainIdFromAlias(sourceChain);\n\n    return await cChain.buildImportTx(\n      utxoSet,\n      toAddress,\n      ownerAddresses,\n      sourceChainId,\n      fromAddresses,\n      fee\n    );\n  }\n\n  /**\n   *\n   * @param sourceChain\n   * @param fee Fee to use in nDJTX\n   * @param utxoSet\n   */\n  async importToCChain(\n    sourceChain: ExportChainsC,\n    fee: BN,\n    utxoSet?: EVMUTXOSet\n  ) {\n    if (!utxoSet) {\n      utxoSet = await this.evmGetAtomicUTXOs(sourceChain);\n    }\n\n    // TODO: Only use DJTX utxos\n    // TODO?: If the import fee for a utxo is greater than the value of the utxo, ignore it\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const unsignedTxFee = await this.createImportTxC(sourceChain, utxoSet, fee);\n    const tx = await this.signC(unsignedTxFee);\n    return this.issueC(tx);\n  }\n\n  protected async issueX(tx: AVMTx) {\n    return issueX(tx);\n  }\n\n  protected async issueP(tx: PlatformTx) {\n    return issueP(tx);\n  }\n\n  protected async issueC(tx: EVMTx) {\n    return issueC(tx);\n  }\n\n  async exportFromXChain(\n    amt: BN,\n    destinationChain: ExportChainsX,\n    importFee?: BN\n  ) {\n    if (destinationChain === \"U\" && !importFee)\n      throw new Error(\"Exports to Utility chain must specify an import fee.\");\n\n    let amtFee = amt.clone();\n\n    // Get destination address\n    const destinationAddr =\n      destinationChain === \"M\"\n        ? this.getCurrentAddressPlatform()\n        : this.getEvmAddressBech();\n\n    // Add import fee to transaction\n    if (importFee) {\n      amtFee = amt.add(importFee);\n    } else if (destinationChain === \"M\") {\n      const fee = pChain.getTxFee();\n      amtFee = amt.add(fee);\n    }\n\n    const fromAddresses = this.getAllAddressesX();\n    const changeAddress = this.getChangeAddressAvm();\n    const utxos = this.getUTXOSet();\n    const exportTx = await TxHelper.buildAvmExportTransaction(\n      destinationChain,\n      utxos,\n      fromAddresses,\n      destinationAddr,\n      amtFee,\n      changeAddress\n    );\n\n    const tx = await this.signX(exportTx);\n\n    return this.issueX(tx);\n  }\n\n  async exportFromPChain(\n    amt: BN,\n    destinationChain: ExportChainsP,\n    importFee?: BN\n  ) {\n    const utxoSet = this.getPlatformUTXOSet();\n\n    const pChangeAddr = this.getCurrentAddressPlatform();\n    const fromAddrs = this.getAllAddressesP();\n\n    if (destinationChain === \"U\" && !importFee)\n      throw new Error(\"Exports to Utility chain must specify an import fee.\");\n\n    // Calculate C chain import fee\n    let amtFee = amt.clone();\n    if (importFee) {\n      amtFee = amt.add(importFee);\n    } else if (destinationChain === \"V\") {\n      // We can add the import fee for X chain\n      const fee = avm.getTxFee();\n      amtFee = amt.add(fee);\n    }\n\n    // Get the destination address for the right chain\n    const destinationAddr =\n      destinationChain === \"U\"\n        ? this.getEvmAddressBech()\n        : this.getCurrentAddressAvm();\n\n    const exportTx = await TxHelper.buildPlatformExportTransaction(\n      utxoSet,\n      fromAddrs,\n      destinationAddr,\n      amtFee,\n      pChangeAddr,\n      destinationChain\n    );\n\n    const tx = await this.signP(exportTx);\n    return await this.issueP(tx);\n  }\n\n  /**\n   *\n   * @param amt The amount to receive on the destination chain, in nDJTX.\n   * @param destinationChain `X` or `P`\n   * @param fee Fee to use in the export transaction, given in nDJTX.\n   */\n  async exportFromCChain(\n    amt: BN,\n    destinationChain: ExportChainsC,\n    exportFee: BN\n  ) {\n    // Add import fee\n    // X and P have the same fee\n    const importFee = avm.getTxFee();\n    const amtFee = amt.add(importFee);\n\n    const hexAddr = this.getEvmAddress();\n    const bechAddr = this.getEvmAddressBech();\n\n    const fromAddresses = [hexAddr];\n\n    const destinationAddr =\n      destinationChain === \"V\"\n        ? this.getCurrentAddressAvm()\n        : this.getCurrentAddressPlatform();\n\n    const exportTx = await TxHelper.buildEvmExportTransaction(\n      fromAddresses,\n      destinationAddr,\n      amtFee,\n      bechAddr,\n      destinationChain,\n      exportFee\n    );\n\n    const tx = await this.signC(exportTx);\n    return this.issueC(tx);\n  }\n\n  /**\n   * Returns the estimated gas to export from C chain.\n   * @param destinationChain\n   * @param amount\n   */\n  async estimateExportFee(\n    destinationChain: ExportChainsC,\n    amount: BN\n  ): Promise<number> {\n    const hexAddr = this.getEvmAddress();\n    const bechAddr = this.getEvmAddressBech();\n\n    const destinationAddr =\n      destinationChain === \"V\"\n        ? this.getCurrentAddressAvm()\n        : this.getCurrentAddressPlatform();\n\n    return GasHelper.estimateExportGasFee(\n      destinationChain,\n      hexAddr,\n      bechAddr,\n      destinationAddr,\n      amount\n    );\n  }\n\n  async avmGetAtomicUTXOs(sourceChain: ExportChainsX) {\n    const addrs = this.getAllAddressesX();\n    return await UtxoHelper.avmGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async platformGetAtomicUTXOs(sourceChain: ExportChainsP) {\n    const addrs = this.getAllAddressesP();\n    return await UtxoHelper.platformGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async importToPlatformChain(sourceChain: ExportChainsP): Promise<string> {\n    const utxoSet = await this.platformGetAtomicUTXOs(sourceChain);\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const sourceChainId = chainIdFromAlias(sourceChain);\n    // Owner addresses, the addresses we exported to\n    const pToAddr = this.getCurrentAddressPlatform();\n\n    const hrp = ava.getHRP();\n    const utxoAddrs = utxoSet\n      .getAddresses()\n      .map((addr) => bintools.addressToString(hrp, \"M\", addr));\n\n    const fromAddrs = utxoAddrs;\n    const ownerAddrs = utxoAddrs;\n\n    const unsignedTx = await pChain.buildImportTx(\n      utxoSet,\n      ownerAddrs,\n      sourceChainId,\n      [pToAddr],\n      [pToAddr],\n      [pToAddr],\n      undefined,\n      undefined\n    );\n    const tx = await this.signP(unsignedTx);\n    // Pass in string because AJS fails to verify Tx type\n    return this.issueP(tx);\n  }\n\n  async importToXChain(sourceChain: AvmImportChainType) {\n    const utxoSet = await this.avmGetAtomicUTXOs(sourceChain);\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const xToAddr = this.getCurrentAddressAvm();\n\n    const hrp = ava.getHRP();\n    const utxoAddrs = utxoSet\n      .getAddresses()\n      .map((addr) => bintools.addressToString(hrp, \"V\", addr));\n\n    const fromAddrs = utxoAddrs;\n    const ownerAddrs = utxoAddrs;\n\n    const sourceChainId = chainIdFromAlias(sourceChain);\n\n    // Owner addresses, the addresses we exported to\n    const unsignedTx = await avm.buildImportTx(\n      utxoSet,\n      ownerAddrs,\n      sourceChainId,\n      [xToAddr],\n      fromAddrs,\n      [xToAddr]\n    );\n\n    const tx = await this.signX(unsignedTx);\n    return this.issueX(tx);\n  }\n}\nexport { WalletCore };\n","// Manages BigNumber and Ava conversion and arithmetic\nimport { BN } from \"avalanche\";\nimport Big from \"big.js\";\n\nclass AvaAsset {\n  id: string;\n  name: string;\n  symbol: string;\n  denomination: number;\n  amount: BN;\n  amountLocked: BN;\n  amountMultisig: BN;\n  // DJT Method chain, Wallet Staking\n  amountExtra: BN;\n  private readonly pow: Big;\n  constructor(id: string, name: string, symbol: string, denomination: number) {\n    this.id = id;\n    this.name = name;\n    this.symbol = symbol;\n    this.denomination = denomination;\n    this.amount = new BN(0, 10);\n    this.amountLocked = new BN(0, 10);\n    this.amountExtra = new BN(0, 10);\n    this.amountMultisig = new BN(0, 10);\n    this.pow = Big(10).pow(denomination);\n  }\n\n  addBalance(val: BN): void {\n    this.amount = this.amount.add(val);\n  }\n\n  addBalanceLocked(val: BN): void {\n    this.amountLocked = this.amountLocked.add(val);\n  }\n  addBalanceMultisig(val: BN): void {\n    this.amountMultisig = this.amountMultisig.add(val);\n  }\n\n  addExtra(val: BN): void {\n    this.amountExtra = this.amountExtra.add(val);\n  }\n\n  resetBalance() {\n    this.amount = new BN(0, 10);\n    this.amountLocked = new BN(0, 10);\n    this.amountExtra = new BN(0, 10);\n    this.amountMultisig = new BN(0, 10);\n  }\n\n  getAmount(locked: boolean = false): Big {\n    if (!locked) {\n      return Big(this.amount.toString(10)).div(this.pow);\n    } else {\n      return Big(this.amountLocked.toString(10)).div(this.pow);\n    }\n  }\n\n  getAmountBN(locked: boolean = false): BN {\n    if (!locked) {\n      return this.amount;\n    } else {\n      return this.amountLocked;\n    }\n  }\n\n  getTotalAmount(): BN {\n    return this.amount\n      .add(this.amountLocked)\n      .add(this.amountExtra)\n      .add(this.amountMultisig);\n  }\n\n  toStringTotal(): string {\n    const big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow);\n    return big.toLocaleString(this.denomination);\n  }\n\n  toString() {\n    const big: Big = Big(this.amount.toString(10)).div(this.pow);\n    return big.toLocaleString(this.denomination);\n  }\n}\n\nexport default AvaAsset;\n"],"sourceRoot":""}